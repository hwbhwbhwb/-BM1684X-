'''lightarg_bmodel2.py
# 导入操作系统模块，用于文件路径和环境变量操作
import os
# 禁用 tiktoken 缓存目录，避免网络请求

os.environ['TOKENIZERS_PARALLELISM'] = 'false'
os.environ['PYTHONUNBUFFERED'] = '1'

import sys
import hashlib
from watchdog.observers.polling import PollingObserver as Observer
from watchdog.events import FileSystemEventHandler

# 添加适配器模块路径
sys.path.append('/data/qwen_embedding')
# 添加 Qwen LLM 适配器路径
sys.path.append('/data/whisper-TPU_py/bmwhisper')

# 导入异步编程模块
import asyncio
# 导入检查模块，用于检查对象类型
import inspect
# 导入日志记录模块
import logging
# 导入日志配置模块
import logging.config
# 导入LightRAG核心组件：主类和查询参数类
from lightrag import LightRAG, QueryParam
# 导入OpenAI兼容的完成函数
from lightrag.llm.openai import openai_complete_if_cache
# 导入工具函数：嵌入函数类、日志器、详细调试设置
from lightrag.utils import EmbeddingFunc, logger, set_verbose_debug
# 导入共享存储的管道状态初始化函数
from lightrag.kg.shared_storage import initialize_pipeline_status
# 导入PyTorch深度学习框架
import torch
import numpy as np
import time

# 导入我们的 LightRAG Qwen 适配器（用于embedding）
from lightrag_qwen_adapter import get_lightrag_embedding_func

# 导入 Qwen LLM 适配器（用于 LLM，通过 HTTP API）
from qwen_llm_adapter import qwen_llm_model_func, MODEL_CONFIG

# 导入简化的共享管理器用于状态检查
from shared_qwen_manager import simple_qwen

# 修改模型路径
MODEL_CONFIG["llm_model_path"] = "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel"
MODEL_CONFIG["config_path"] = "/data/LLM-TPU/models/Qwen3/python_demo/config"
MODEL_CONFIG["temperature"] = 0.5

# 定义工作目录路径
WORKING_DIR = "./result/biography_final"
# 在 WORKING_DIR 定义后添加输出目录配置
OUTPUT_DIR = "/data/mermaidRender/dist"

# 确保输出目录存在
if not os.path.exists(OUTPUT_DIR):
    print(f"Creating output directory: {OUTPUT_DIR}")
    os.makedirs(OUTPUT_DIR)
else:
    print(f"Output directory already exists: {OUTPUT_DIR},continue...")
    
# 如果工作目录不存在，则创建该目录
if not os.path.exists(WORKING_DIR):
    print(f"Setting directory not exist,creating working directory: {WORKING_DIR}")
    os.mkdir(WORKING_DIR)
else:
    print(f"Working directory already exists: {WORKING_DIR},continue...")

# 文件监控处理器类 - 修改版本
class QuestionFileHandler(FileSystemEventHandler):
    """问题文件变化监控处理器"""
    def __init__(self, callback, loop):
        self.callback = callback
        self.last_content_hash = None
        self.loop = loop  # 保存事件循环引用
        
    def on_modified(self, event):
        if not event.is_directory and event.src_path.endswith('ragQuestions.txt'):
            # 检查文件内容是否真的改变了
            try:
                with open(event.src_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                content_hash = hashlib.md5(content.encode()).hexdigest()
                
                if content_hash != self.last_content_hash:
                    self.last_content_hash = content_hash
                    # 使用 run_coroutine_threadsafe 安全地在事件循环中调度协程
                    asyncio.run_coroutine_threadsafe(
                        self.callback(event.src_path), 
                        self.loop
                    )
            except Exception as e:
                print(f"读取文件时出错: {e}")

# 定义日志配置函数
def configure_logging():
    """配置应用程序的日志记录"""
    # 重置现有的处理程序以确保干净的配置
    for logger_name in ["uvicorn", "uvicorn.access", "uvicorn.error", "lightrag"]:
        logger_instance = logging.getLogger(logger_name)
        logger_instance.handlers = []
        logger_instance.filters = []

    # 从环境变量获取日志目录路径，默认使用当前目录
    log_dir = os.getenv("LOG_DIR", os.getcwd())
    # 构建日志文件的绝对路径
    log_file_path = os.path.abspath(
        os.path.join(log_dir, "lightrag_qwen_bmodel_demo.log")
    )

    print(f"\nLightRAG Qwen embedding bmodel demo log file: {log_file_path}\n")
    os.makedirs(os.path.dirname(log_dir), exist_ok=True)

    # 从环境变量获取日志文件最大大小和备份数量
    log_max_bytes = int(os.getenv("LOG_MAX_BYTES", 10485760))  # 默认10MB
    log_backup_count = int(os.getenv("LOG_BACKUP_COUNT", 5))  # 默认5个备份

    # 配置日志系统
    logging.config.dictConfig(
        {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "format": "%(levelname)s: %(message)s",
                },
                "detailed": {
                    "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                },
            },
            "handlers": {
                "console": {
                    "formatter": "default",
                    "class": "logging.StreamHandler",
                    "stream": "ext://sys.stderr",
                },
                "file": {
                    "formatter": "detailed",
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": log_file_path,
                    "maxBytes": log_max_bytes,
                    "backupCount": log_backup_count,
                    "encoding": "utf-8",
                },
            },
            "loggers": {
                "lightrag": {
                    "handlers": ["console", "file"],
                    "level": "INFO",
                    "propagate": False,
                },
            },
        }
    )

    logger.setLevel(logging.INFO)
    set_verbose_debug(os.getenv("VERBOSE_DEBUG", "false").lower() == "true")

# 定义流式输出打印函数
async def print_stream(stream):
    async for chunk in stream:
        if chunk:
            print(chunk, end="", flush=True)

# 检查模型状态的函数
def check_model_availability():
    """检查模型是否可用"""
    try:
        status = simple_qwen.get_status()
        print(f"模型状态检查: {status}")
        
        if status["local_model"] or status["external_model"]:
            print("✅ 检测到可用的 LLM 模型")
            return True
        else:
            print("⚠️ 未检测到可用的 LLM 模型")
            return False
    except Exception as e:
        print(f"❌ 模型状态检查失败: {e}")
        return False

# 检查 API 服务器状态
def check_api_server_status():
    """检查API服务器状态"""
    try:
        import requests
        response = requests.get("http://localhost:8899/status", timeout=5)
        if response.status_code == 200:
            status = response.json()
            print(f"✅ API服务器可用: {status}")
            return True
        else:
            print(f"⚠️ API服务器响应异常: {response.status_code}")
            return False
    except Exception as e:
        print(f"❌ API服务器不可用: {e}")
        return False

async def initialize_rag():
    """使用 Qwen embedding bmodel + HTTP LLM API 初始化 RAG 系统"""
    
    print("正在初始化 LightRAG with Qwen embedding bmodel + HTTP LLM API...")
    
    # 1. 检查 LLM 模型状态
    print("\n=== 检查 LLM 模型状态 ===")
    llm_available = check_model_availability()
    api_available = check_api_server_status()
    
    if not (llm_available or api_available):
        print("⚠️ 警告：LLM 模型和API服务器都不可用")
        print("请确保 sample_audio.py 正在运行")
        print("继续初始化，但LLM功能可能受限...")
    else:
        print("✅ LLM 模型通过 HTTP API 可用")
    
    # 2. 初始化 Embedding 模型（本地加载）
    print("\n=== 初始化 Embedding 模型 ===")
    try:
        qwen_embedding_func = get_lightrag_embedding_func(
            model_path='/data/Qwen3_Embedding_0.6B_my_1684x_128_f16.bmodel',
            tokenizer_path=None,
            batch_size=1,
            device="tpu",
            async_mode=True
        )
        print("✅ Embedding 模型初始化成功（本地bmodel）")
    except Exception as e:
        print(f"❌ Embedding 模型初始化失败: {e}")
        raise
    
    # 3. 创建 LightRAG 实例
    print("\n=== 创建 LightRAG 实例 ===")
    try:
        # 创建自定义 tokenizer 来替代 tiktoken
        class SimpleChineseTokenizer:
            """简单的中文分词器，避免使用 tiktoken"""
            
            def encode(self, text: str) -> list[int]:
                """将文本编码为 token ID 列表"""
                # 字符级编码，适合中文
                return [ord(c) for c in text if ord(c) <= 65535]  # 过滤超出BMP的字符
            
            def decode(self, tokens: list[int]) -> str:
                """将 token ID 列表解码为文本"""
                try:
                    return ''.join([chr(t) for t in tokens if 0 <= t <= 65535])
                except ValueError:
                    return ""
        
        # 创建 tokenizer 实例
        from lightrag.utils import Tokenizer
        custom_tokenizer = Tokenizer(
            model_name="chinese_custom", 
            tokenizer=SimpleChineseTokenizer()
        )
        
        print("✅ 自定义 tokenizer 创建成功（无需 tiktoken）")
        
        # 创建LightRAG实例，使用HTTP API的LLM + 本地embedding + 自定义tokenizer
        rag = LightRAG(
            working_dir=WORKING_DIR,
            llm_model_func=qwen_llm_model_func,  # 使用HTTP API
            embedding_func=EmbeddingFunc(
                embedding_dim=1024,
                max_token_size=5000,
                func=qwen_embedding_func,  # 使用本地bmodel
            ),
            tokenizer=custom_tokenizer,  # 关键：使用自定义tokenizer
            tiktoken_model_name=None,     # 确保不使用tiktoken
        )
        print("✅ LightRAG 实例创建成功")
        
    except Exception as e:
        print(f"❌ LightRAG 初始化失败: {e}")
        print("尝试使用最小配置重新初始化...")
        
        # 备用方案：更简单的tokenizer
        class BasicTokenizer:
            def encode(self, text: str) -> list[int]:
                # 最简单的字节编码
                return list(text.encode('utf-8'))
            
            def decode(self, tokens: list[int]) -> str:
                try:
                    return bytes(tokens).decode('utf-8', errors='ignore')
                except:
                    return ""
        
        from lightrag.utils import Tokenizer
        basic_tokenizer = Tokenizer(
            model_name="basic", 
            tokenizer=BasicTokenizer()
        )
        
        rag = LightRAG(
            working_dir=WORKING_DIR,
            llm_model_func=qwen_llm_model_func,
            embedding_func=EmbeddingFunc(
                embedding_dim=1024,
                max_token_size=5000,
                func=qwen_embedding_func,
            ),
            tokenizer=basic_tokenizer,    # 使用基础tokenizer
            tiktoken_model_name=None,
        )

    # 4. 初始化存储系统
    print("\n=== 初始化存储系统 ===")
    try:
        await rag.initialize_storages()
        await initialize_pipeline_status()
        print("✅ 存储系统初始化完成")
    except Exception as e:
        print(f"⚠️ 存储系统初始化出现问题: {e}")
        print("继续运行...")

    print("✅ LightRAG 初始化完成（Embedding本地 + LLM远程API）")
    return rag

# 问题文件解析函数
def parse_question_file(file_path: str) -> tuple:
    """解析问题文件，返回 (序号, 问题内容)"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        
        if len(lines) >= 2:
            sequence_num = lines[0]
            question = lines[1]
            return sequence_num, question
        elif len(lines) == 1:
            # 只有一行，当作问题处理
            return "1", lines[0]
        else:
            return None, None
            
    except FileNotFoundError:
        print(f"问题文件 {file_path} 不存在")
        return None, None
    except Exception as e:
        print(f"解析问题文件时出错: {e}")
        return None, None

# 文档接口函数
def read_questions_from_file(file_path: str) -> list:
    """从文件中读取问题列表"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            questions = [line.strip() for line in f if line.strip()]
        return questions
    except FileNotFoundError:
        print(f"Warning: {file_path} not found, using default question")
        return ["介绍白血病与白细胞的关系"]  # 默认问题

def save_chunk_ids(chunk_ids: list, file_path: str):
    """将chunk ID保存到文件"""
    with open(file_path, 'w', encoding='utf-8') as f:
        for chunk_id in chunk_ids:
            f.write(f"{chunk_id}\n")
    print(f"Chunk IDs saved to: {file_path}")

# 处理单个问题的函数
async def process_single_question(rag, question: str, sequence_num: str):
    """处理单个问题的完整流程"""
    print(f"\n{'='*60}")
    print(f"处理问题序号 {sequence_num}: {question}")
    print('='*60)
    
    try:
        # 1. 直接调用 chunks_vdb.query 来获取检索结果
        print("\n=====================")
        print("Direct chunk search")
        print("=====================")
        start_time = time.time()
        
        try:
            chunks_result = await rag.chunks_vdb.query(
                query=question,
                top_k=5,
                ids=None
            )
            
            # 提取 chunk IDs
            chunk_ids = [chunk.get('id', 'N/A') for chunk in chunks_result]
            
            # 打印查询结果
            print(f"检索到 {len(chunks_result)} 个相关 chunks:")
            for i, chunk in enumerate(chunks_result):
                print(f"\nChunk {i+1}:")
                print(f"  ID: {chunk.get('id', 'N/A')}")
                print(f"  Score: {chunk.get('distance', 'N/A')}")
                print(f"  Content: {chunk.get('content', '')[:100]}...")
                print(f"  Full Doc ID: {chunk.get('full_doc_id', 'N/A')}")
                print(f"  Chunk Order Index: {chunk.get('chunk_order_index', 'N/A')}")
                print(f"  File Path: {chunk.get('file_path', 'N/A')}")

            # 2. 保存 chunk IDs 到 ragSearch.txt
            chunk_ids_file = os.path.join(OUTPUT_DIR, "ragSearch.txt")
            save_chunk_ids(chunk_ids, chunk_ids_file)
            
        except Exception as e:
            print(f"⚠️ Chunk 检索失败: {e}")
            chunk_ids_file = os.path.join(OUTPUT_DIR, "ragSearch.txt")
            save_chunk_ids(["检索失败"], chunk_ids_file)
        
        # 3. 执行完整的RAG查询
        print(f"\n=====================")
        print("Query mode: naive - Full RAG Search")
        print("=====================")
        start_time = time.time()
        
        try:
            resp = await rag.aquery(
                question,
                param=QueryParam(mode="naive", stream=True),
            )
            end_time = time.time()
            print(f"Search execution time: {end_time - start_time:.2f} seconds")
            
            # 替换原有的 if inspect.isasyncgen(resp): ... else: ... 逻辑
            response_file = os.path.join(OUTPUT_DIR, "RAGResult.txt")

            # 确保文件在使用前是空的
            with open(response_file, 'w', encoding='utf-8') as f:
                f.write("") # 清空文件

            print("Response lightrag_bmodel2 success:")
            # 以追加模式打开文件，在循环中写入
            with open(response_file, 'a', encoding='utf-8') as f:
                if inspect.isasyncgen(resp):
                    # 流式响应
                    async for chunk in resp:
                        if chunk:
                            # 同时输出到终端和文件
                            print(chunk, end="", flush=True)
                            f.write(chunk)
                            f.flush() # 关键：确保立即写入磁盘
                else:
                    # 非流式响应（作为备用逻辑）
                    response_text = str(resp)
                    print(response_text)
                    f.write(response_text)

            # 循环结束后换行，美化终端输出
            print() 

            print(f"\n问题序号 {sequence_num} 处理完成")
            print(f"- Chunk IDs 保存至: {chunk_ids_file}")
            print(f"- 响应流式保存至: {response_file}")

            return True
            
        except Exception as e:
            print(f"⚠️ RAG 查询失败: {e}")
            # 尝试直接使用 LLM
            print("尝试直接使用 LLM 回答...")
            
            return False
        
    except Exception as e:
        print(f"处理问题时出错: {e}")
        import traceback
        traceback.print_exc()

        return False

# 监控和处理问题的主函数 - 修改版本
async def monitor_and_process_questions(rag):
    """监控问题文件并处理"""
    questions_file = os.path.join(OUTPUT_DIR, "ragQuestions.txt")
    processed_sequences = set()  # 记录已处理的序号
    
    async def handle_file_change(file_path):
        """处理文件变化"""
        try:
            # 检查文件是否为空
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            if not content:
                print("问题文件为空，等待用户输入问题...")
                return
            
            sequence_num, question = parse_question_file(file_path)
            
            if sequence_num and question:
                # 检查是否是新问题（基于序号）
                if sequence_num not in processed_sequences:
                    print(f"\n检测到新问题: 序号 {sequence_num}")
                    success = await process_single_question(rag, question, sequence_num)
                    
                    if success:
                        processed_sequences.add(sequence_num)
                        print(f"问题序号 {sequence_num} 处理成功")
                    else:
                        print(f"问题序号 {sequence_num} 处理失败")
                else:
                    print(f"问题序号 {sequence_num} 已处理过，跳过")
            else:
                print("问题文件格式不正确或为空")
        except Exception as e:
            print(f"处理文件变化时出错: {e}")
            import traceback
            traceback.print_exc()
    
    # 获取当前事件循环
    loop = asyncio.get_running_loop()
    
    # 创建文件监控处理器，传入事件循环
    event_handler = QuestionFileHandler(callback=handle_file_change, loop=loop)
    
    # 设置文件监控
    observer = Observer()
    observer.schedule(event_handler, OUTPUT_DIR, recursive=False)
    observer.start()
    
    print(f"开始监控问题文件: {questions_file}")
    print("请在 ragQuestions.txt 中写入问题，格式如下:")
    print("第一行: 序号")
    print("第二行: 问题内容")
    print("按 Ctrl+C 退出监控")
    
    # 初始化时读取当前序号，但不处理
    if os.path.exists(questions_file):
        try:
            sequence_num, _ = parse_question_file(questions_file)
            if sequence_num:
                processed_sequences.add(sequence_num)
                print(f"检测到现有问题文件，当前序号: {sequence_num}，等待序号变化...")
        except:
            pass
    
    try:
        # 保持监控运行
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        print("\n停止文件监控")
        observer.stop()
    
    observer.join()

def create_example_question_file():
    """创建空的问题文件"""
    questions_file = os.path.join(OUTPUT_DIR, "ragQuestions.txt")
    if not os.path.exists(questions_file):
        # 创建空文件，不写入任何内容
        with open(questions_file, 'w', encoding='utf-8') as f:
            f.write("")
        
        print(f"创建空的问题文件: {questions_file}")
        print("等待用户输入问题...")
    else:
        print(f"问题文件已存在: {questions_file}")
        print("等待问题序号变化...")

# 定义异步主函数
async def main():
    try:
        # 首先检查模型状态
        print("=" * 60)
        print("检查系统状态...")
        print("=" * 60)
        
        llm_available = check_model_availability()
        api_available = check_api_server_status()
        
        if not (llm_available or api_available):
            print("⚠️ 警告：LLM模型可能未准备就绪")
            print("请确保 sample_audio.py 正在运行")
            print("继续初始化，将尝试通过API访问...")
        
        # 初始化RAG实例
        print("\n" + "=" * 60)
        print("初始化 RAG 系统...")
        print("=" * 60)
        
        rag = await initialize_rag()

        # # 测试嵌入函数
        # test_text = ["This is a test string for embedding with Qwen embedding bmodel."]
        # print("\n=======================")
        # print("Testing Qwen embedding bmodel embedding function")
        # print("========================")
        # print(f"Test text: {test_text}")
        
        # try:
        #     embedding = await rag.embedding_func(test_text)
        #     embedding_dim = embedding.shape[1]
        #     print(f"✅ Detected embedding dimension: {embedding_dim}")
        #     print(f"Embedding shape: {embedding.shape}")
        #     print(f"First 10 values: {embedding[0][:10]}\n")
        # except Exception as e:
        #     print(f"⚠️ Embedding 测试失败: {e}")

        # # 测试LLM函数
        # print("\n=======================")
        # print("Testing Qwen LLM HTTP API function")
        # print("========================")
        # test_prompt = "你好，请简单介绍一下你自己。"
        # print(f"Test prompt: {test_prompt}")
        
        # try:
        #     llm_response = await rag.llm_model_func(
        #         test_prompt,
        #         system_prompt="你是一个有用的助手。"
        #     )
        #     print(f"✅ LLM Response: {llm_response}\n")
        # except Exception as e:
        #     print(f"⚠️ LLM 测试失败: {e}")
        #     print("可能原因：sample_audio.py 未运行或API服务器未启动")
        
        # 创建示例问题文件
        create_example_question_file()
        
        # 开始监控和处理问题
        print("\n" + "=" * 60)
        print("开始问题监控...")
        print("=" * 60)
        
        await monitor_and_process_questions(rag)
        
    except Exception as e:
        print(f"An error occurred: {e}")
        import traceback
        traceback.print_exc()
    finally:
        if 'rag' in locals():
            try:
                await rag.finalize_storages()
            except:
                pass

# 程序入口点
if __name__ == "__main__":
    # 在运行主函数前配置日志
    configure_logging()
    
    print("🚀 启动 LightRAG with Qwen bmodel (混合模式)")
    print("=" * 60)
    print("架构说明:")
    print("- LLM: 通过 HTTP API 访问 (qwen_llm_adapter.py)")
    print("- Embedding: 直接加载本地 bmodel")
    print("- 注意：请确保 sample_audio.py 正在运行以提供LLM服务")
    print("=" * 60)
    
    # 运行异步主函数
    asyncio.run(main())
    
    # 打印完成信息
    print("\nDone! Qwen embedding bmodel integration with LightRAG completed successfully.")
'''
'''sample_audio.py
import pyaudio
import wave
import threading
import queue
import os
import time
import json
from datetime import datetime
import globalConfig
import random
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import urllib.parse

os.environ['TOKENIZERS_PARALLELISM'] = 'false'

# 导入简化的共享管理器
from shared_qwen_manager import simple_qwen, generate_mermaid, generate_text

# 参数设置
FORMAT = pyaudio.paInt16  # 16位采样
CHANNELS = 1              # 单声道
RATE = 16000              # 采样率（Hz）
CHUNK = 1024              # 每个缓冲区的帧数
RECORD_SECONDS = 30       # 每个文件录音时长
RECORDING_FOLDER = "recordings"  # 录音文件保存文件夹

# 创建保存录音的文件夹
os.makedirs(RECORDING_FOLDER, exist_ok=True)

# 创建一个队列用于存储待处理的音频文件
audio_queue = queue.Queue()

exitFlag = False

class QwenAPIHandler(BaseHTTPRequestHandler):
    """简单的HTTP API处理器，用于跨进程推理"""
    
    def do_POST(self):
        if self.path == '/generate':
            try:
                # 读取请求数据
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                data = json.loads(post_data.decode('utf-8'))
                
                prompt = data.get('prompt', '')
                max_new_tokens = data.get('max_new_tokens', 512)
                
                if not prompt:
                    self.send_error(400, "Missing prompt")
                    return
            
                self.send_response(200)
                self.send_header('Content-type', 'text/plain; charset=utf-8')
                # 关键：启用分块传输
                self.send_header('Transfer-Encoding', 'chunked') 
                self.end_headers()

                # result_generator 是一个生成器
                result_generator = generate_text(prompt, max_new_tokens)

                for chunk in result_generator:
                    if chunk:
                        # 编码数据块
                        encoded_chunk = chunk.encode('utf-8')
                        # 获取数据块长度的十六进制表示
                        chunk_size = f"{len(encoded_chunk):X}\r\n".encode('utf-8')
                        # 写入块大小
                        self.wfile.write(chunk_size)
                        # 写入数据块
                        self.wfile.write(encoded_chunk)
                        # 写入块结束符
                        self.wfile.write(b"\r\n")
                        # 刷新缓冲区，确保立即发送
                        self.wfile.flush()

                # 发送一个大小为0的块，表示传输结束
                self.wfile.write(b"0\r\n\r\n")
                self.wfile.flush()
                
            except Exception as e:
                error_response = {'error': str(e), 'status': 'error'}
                self.send_response(500)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(error_response).encode('utf-8'))
    
    def do_GET(self):
        if self.path == '/status':
            # 返回模型状态
            status = simple_qwen.get_status()
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(status).encode('utf-8'))
        else:
            self.send_error(404, "Not found")
    
    def log_message(self, format, *args):
        # 禁用默认日志输出
        pass

def start_api_server():
    """启动API服务器"""
    try:
        server = HTTPServer(('localhost', 8899), QwenAPIHandler)
        print("🌐 API服务器启动在 http://localhost:8899")
        print("  - POST /generate : 文本生成")
        print("  - GET /status : 模型状态")
        server.serve_forever()
    except Exception as e:
        print(f"❌ API服务器启动失败: {e}")

def initEnv():
    import os
    # 设置环境变量
    os.environ["LOG_LEVEL"] = "-1"
    os.environ["LD_LIBRARY_PATH"] = "/opt/sophon/libsophon-current/lib:" + os.environ.get("LD_LIBRARY_PATH", "")

    # 启动 pulseaudio（忽略错误）
    os.system("pulseaudio --start 2>/dev/null || true")

def initMermaid(text):
    template = f"""
graph LR
    A[{text}开启全新教学模式] --> B[思维导图]
    A --> C[课本查询]
    A --> D[互动提问]
    A --> E[历史笔记]
"""
    # Ensure the output directory exists
    os.makedirs('/data/mermaidRender/text', exist_ok=True)
    with open('/data/mermaidRender/text/outmermaid.mmd', "w") as f:
        f.write(template)

def record_audio():
    """录音线程：持续录音并每10秒保存一个文件"""
    # 初始化PyAudio
    audio = pyaudio.PyAudio()
    
    # 打开流
    stream = audio.open(format=FORMAT,
                        channels=CHANNELS,
                        rate=RATE,
                        input=True,
                        frames_per_buffer=CHUNK)
    
    print("录音线程已启动")
    last_state = True
    try:
        while True:
            if exitFlag:
                print("record_audio线程退出")
                break
            if not globalConfig.running:
                time.sleep(1)
                last_state = False
                continue
            # 清空输入缓冲区，避免残留数据影响新录音
            if(not last_state):
                print("录音线程开始，清空输入缓冲区...")
                initMermaid("正在采集中...")
                last_state = True
                stream.stop_stream()
                stream.start_stream()

            frames = []
            filename = os.path.join(
                RECORDING_FOLDER,
                f"audio_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}_{random.randint(1000,9999)}.wav"
            )
            print(f"开始录制文件: {filename}")
            
            # 录制指定秒数的音频
            for _ in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
                if not globalConfig.running:
                    break
                data = stream.read(CHUNK)
                frames.append(data)
            
            # 保存为WAV文件
            if frames:  # 确保有数据再保存
                wf = wave.open(filename, 'wb')
                wf.setnchannels(CHANNELS)
                wf.setsampwidth(audio.get_sample_size(FORMAT))
                wf.setframerate(RATE)
                wf.writeframes(b''.join(frames))
                wf.close()
                
                # 将文件名添加到处理队列
                audio_queue.put(filename)
                print(f"文件已保存: {filename}")
    
    finally:
        # 停止和关闭流
        stream.stop_stream()
        stream.close()
        audio.terminate()
        print("录音线程已结束")

def remove_tail_repeats_auto(s: str) -> str:
    """
    自动判断重复片段长度，从后向前删除连续重复的字符串段，只保留第一次出现。
    支持多种长度的重复递归去重。
    """
    n = len(s)
    changed = True
    while changed:
        changed = False
        for seg_len in range(n // 2, 0, -1):
            # 检查结尾是否有连续重复
            last_seg = s[-seg_len:]
            count = 1
            for i in range(2, n // seg_len + 1):
                start = -i * seg_len
                end = -(i - 1) * seg_len if -(i - 1) * seg_len != 0 else None
                if s[start:end] == last_seg:
                    count += 1
                else:
                    break
            if count > 1:
                cutoff = len(s) - (count - 1) * seg_len
                s = s[:cutoff]
                n = len(s)
                changed = True
                break  # 重新从最大长度开始
    return s

def join_segments_text(segments):
    """
    接收一个包含若干字典（每个字典是一个segment，含'text'字段）的列表，
    返回所有text字段拼接的字符串，用逗号分隔。
    """
    texts = [segment['text'] for segment in segments]
    return '，'.join(texts)  # 使用中文逗号拼接

def clean_mermaid_to_lr(text: str) -> str:
    """
    清理 Mermaid 图内容：
    - 删除 ```mermaid 和 ```
    - 将 graph TD 替换为 graph LR
    """
    lines = text.strip().splitlines()
    cleaned_lines = []
    inside_code_block = False

    for line in lines:
        stripped = line.strip()
        if stripped == "```mermaid":
            inside_code_block = True
            continue
        elif stripped == "```":
            inside_code_block = False
            continue
        elif inside_code_block:
            if stripped.startswith("graph TD"):
                cleaned_lines.append(stripped.replace("graph TD", "graph LR", 1))
            else:
                cleaned_lines.append(line)
    
    return "\n".join(cleaned_lines)

def process_audio(whisperModel):
    """处理线程：处理队列中的音频文件并删除"""
    print("处理线程已启动，等待文件...")
    text = ""
    last_qwen_time = 0
    while True:
        if exitFlag:
            print("process_audio处理线程退出")
            break
        if not globalConfig.running:
            text = ""   
            # 清空所有待处理内容
            while not audio_queue.empty():
                try:
                    filename = audio_queue.get_nowait()
                    audio_queue.task_done()
                    os.remove(filename)
                    print(f"清理: {filename}")
                except queue.Empty:
                    break
            time.sleep(1)
            continue
        try:
            # 从队列中获取文件名
            filename = audio_queue.get()
            
            # 这里添加你的音频处理代码
            print(f"正在处理文件: {filename}")

            resWhisper = whisperModel.transcribe_audio(filename)
            resWhisperText = remove_tail_repeats_auto(join_segments_text(resWhisper["segments"]))
            if(resWhisperText == ''):
                print("内容为空")
                # 标记任务完成并删除文件
                audio_queue.task_done()
                os.remove(filename)
                print(f"文件已删除: {filename}")
                continue
            text += resWhisperText
            #text写入文本
            with open('out.txt', "w") as f:
                f.write(text)
            print(text)
            # Qwen生成间隔控制
            now = time.time()
            if now - last_qwen_time >= globalConfig.qwen_interval:
                print(f"文本长度: {len(text)}")
                
                # 使用简化的任务函数
                try:
                    res = generate_mermaid(text, len(text)*3)
                    last_qwen_time = now
                    
                    if res:
                        # 把res的内容写入文件
                        os.makedirs('/data/mermaidRender/text', exist_ok=True)
                        with open('/data/mermaidRender/dist/text/outmermaid.mmd', "w") as f:
                            f.write(clean_mermaid_to_lr(res))
                        print("思维导图已更新")
                    else:
                        print("思维导图生成失败")
                        
                except Exception as e:
                    print(f"Qwen 处理失败: {e}")
                
            print(f"文件处理完成: {filename}")
            print(f"处理结果: {text}")

            # 标记任务完成
            audio_queue.task_done()
            os.remove(filename)
            print(f"文件已删除: {filename}")
        except queue.Empty:
            # 队列为空，等待globalConfig.running为True再继续
            time.sleep(1)
            continue
        except Exception as e:
            print(f"处理音频时出错: {e}")
            # 确保任务被标记为完成，即使出错
            try:
                audio_queue.task_done()
                if 'filename' in locals() and os.path.exists(filename):
                    os.remove(filename)
            except:
                pass

def initModel():
    """初始化模型"""
    print("=== 初始化模型 ===")
    
    # 首先检查共享管理器状态
    status = simple_qwen.get_status()
    print(f"共享管理器初始状态: {status}")
    
    # 初始化 Qwen 模型（如果尚未加载）
    if not simple_qwen.is_loaded():
        print("🔄 初始化 Qwen 模型...")
        initMermaid("加载Qwen模型...")
        
        class Args:
            model_path = "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel"
            config_path = "/data/LLM-TPU/models/Qwen3/python_demo/config"
            devid = "0"
            temperature = 0.5
            top_p = 1.0
            repeat_penalty = 1.8
            repeat_last_n = 32
            max_new_tokens = 1024
            generation_mode = "greedy"
            prompt_mode = "prompted"
            enable_history = False

        args = Args()
        
        try:
            simple_qwen.initialize_model(args)
            print("✅ Qwen 模型初始化完成")
        except Exception as e:
            print(f"❌ Qwen 模型初始化失败: {e}")
            raise
    else:
        print("✅ Qwen 模型已经加载")
    
    # 初始化 Whisper 模型
    print("🔄 初始化 Whisper 模型...")
    initMermaid("加载Whisper模型...")
    
    try:
        from transcribef import TranscribeWorker
        worker = TranscribeWorker()
        print("✅ Whisper 模型初始化完成")
    except Exception as e:
        print(f"❌ Whisper 模型初始化失败: {e}")
        raise
    
    initMermaid("")
    
    # 验证最终状态
    final_status = simple_qwen.get_status()
    print(f"模型初始化完成后状态: {final_status}")
    
    return worker

if __name__ == "__main__":
    try:
        print("🚀 启动语音识别思维导图系统...")
        
        # 初始化环境
        initEnv()
        
        # 初始化模型
        worker = initModel()
        
        # 启动API服务器（在单独线程中）
        api_thread = threading.Thread(target=start_api_server, daemon=True)
        api_thread.start()
        
        # 创建并启动录音线程
        record_thread = threading.Thread(target=record_audio)
        record_thread.start()
        
        # 创建并启动处理线程 - 注意这里只传入 worker
        process_thread = threading.Thread(target=process_audio, args=(worker,))
        process_thread.start()

        # 创建并启动配置监控线程
        config_thread = threading.Thread(target=globalConfig.config_watcher, daemon=True)
        config_thread.start()
        
        print("系统启动完成！按 Ctrl+C 退出...")
        print("=" * 50)
        
        # 主线程等待用户中断
        while True:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\n正在停止所有线程...")
        exitFlag = True
        
        # 等待线程结束
        print("等待录音线程结束...")
        record_thread.join(timeout=3)
        
        print("等待处理线程结束...")
        process_thread.join(timeout=3)
        
        # 清理剩余文件
        print("清理剩余文件...")
        while not audio_queue.empty():
            try:
                filename = audio_queue.get_nowait()
                audio_queue.task_done()
                if os.path.exists(filename):
                    os.remove(filename)
                print(f"清理: {filename}")
            except queue.Empty:
                break
            except Exception as e:
                print(f"清理文件时出错: {e}")
        
        # 关闭共享管理器
        simple_qwen.shutdown()
        
        print("所有线程已停止，程序退出")
        
    except Exception as e:
        print(f"程序运行出错: {e}")
        import traceback
        traceback.print_exc()
        
        # 确保清理
        exitFlag = True
        simple_qwen.shutdown()
'''
'''shared_qwen_manager.py
import os
import json
import threading
from typing import Optional
from pipelinef import Qwen2

class SimpleQwenManager:
    """简化的 Qwen 模型管理器 - 仅用于本地管理"""
    
    _instance: Optional['SimpleQwenManager'] = None
    _lock = threading.Lock()
    
    # 状态文件
    STATUS_FILE = "/tmp/qwen_model_status.json"
    
    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._initialized = False
            return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
            
        self.model: Optional[Qwen2] = None
        self.model_lock = threading.RLock()
        self._initialized = True
    
    def _write_status_file(self, status):
        """写入状态文件"""
        try:
            with open(self.STATUS_FILE, 'w') as f:
                json.dump(status, f, indent=2)
        except Exception as e:
            print(f"写入状态文件失败: {e}")
    
    def _read_status_file(self):
        """读取状态文件"""
        try:
            if os.path.exists(self.STATUS_FILE):
                with open(self.STATUS_FILE, 'r') as f:
                    return json.load(f)
        except:
            pass
        return {"model_loaded": False, "pid": None, "model_path": None}
    
    def initialize_model(self, args):
        """初始化模型"""
        with self.model_lock:
            if self.model is None:
                print("🔄 初始化 Qwen 模型...")
                self.model = Qwen2(args)
                
                # 更新状态文件
                status = {
                    "model_loaded": True,
                    "pid": os.getpid(),
                    "model_path": args.model_path,
                    "timestamp": __import__('time').time()
                }
                self._write_status_file(status)
                
                print("✅ Qwen 模型初始化完成")
            else:
                print("✅ 模型已经加载")
    
    def get_model(self):
        """获取模型实例"""
        return self.model
    
    def is_loaded(self):
        """检查模型是否已加载"""
        return self.model is not None
    
    def get_status(self):
        """获取状态（主要用于兼容性）"""
        status = self._read_status_file()
        return {
            "model_loaded": self.model is not None,
            "local_model": self.model is not None,
            "external_model": status.get("model_loaded", False) and status.get("pid") != os.getpid(),
            "external_pid": status.get("pid"),
            "current_pid": os.getpid()
        }
    
    def shutdown(self):
        """关闭管理器"""
        if self.model is not None:
            print("🔄 清理模型状态...")
            self._write_status_file({"model_loaded": False, "pid": None, "model_path": None})
        print("✅ 模型管理器已关闭")

# 全局单例
simple_qwen = SimpleQwenManager()

# 简化的任务函数
def generate_mermaid(text, maxWord):
    """思维导图生成"""
    if simple_qwen.model:
        return simple_qwen.model.chat(text, maxWord)
    else:
        raise RuntimeError("模型未加载")

def generate_text(prompt, max_new_tokens=512):
    if simple_qwen.model:
        # model.generate_text 现在是一个生成器，我们用 yield from 将其内容继续向外传
        yield from simple_qwen.model.generate_text(prompt, max_new_tokens)
    else:
        raise RuntimeError("模型未加载")
'''
'''qwen_llm_adapter.py
"""
Qwen LLM bmodel 适配器 - 使用HTTP API访问远程模型
为 LightRAG 提供本地 Qwen bmodel 推理接口
"""
import sys
import os
import asyncio
import signal
import requests
import json
import time
from typing import List, Optional, AsyncIterator

# 导入简化的共享管理器用于状态检查
sys.path.append('/data/whisper-TPU_py/bmwhisper')
from shared_qwen_manager import simple_qwen

# ============ 模型路径配置 ============
MODEL_CONFIG = {
    "llm_model_path": "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel",
    "config_path": "/data/LLM-TPU/models/Qwen3/python_demo/config",
    "device_id": "0",
    "temperature": 0.5,
    "top_p": 1.0,
    "repeat_penalty": 1.0,
    "repeat_last_n": 32,
    "max_new_tokens": 512,
    "generation_mode": "greedy"
}
# =====================================

# API配置
API_BASE_URL = "http://localhost:8899"

class QwenLLMAdapter:
    """Qwen LLM bmodel 适配器类 - 通过HTTP API访问模型"""
    
    def __init__(self, **kwargs):
        self.config = {
            "model_path": kwargs.get("model_path", MODEL_CONFIG["llm_model_path"]),
            "config_path": kwargs.get("config_path", MODEL_CONFIG["config_path"]),
            "device_id": kwargs.get("device_id", MODEL_CONFIG["device_id"]),
            "temperature": kwargs.get("temperature", MODEL_CONFIG["temperature"]),
            "top_p": kwargs.get("top_p", MODEL_CONFIG["top_p"]),
            "repeat_penalty": kwargs.get("repeat_penalty", MODEL_CONFIG["repeat_penalty"]),
            "repeat_last_n": kwargs.get("repeat_last_n", MODEL_CONFIG["repeat_last_n"]),
            "max_new_tokens": kwargs.get("max_new_tokens", MODEL_CONFIG["max_new_tokens"]),
            "generation_mode": kwargs.get("generation_mode", MODEL_CONFIG["generation_mode"]),
            "prompt_mode": "prompted",
            "enable_history": False
        }
        
        self._check_model_availability()
    
    def _check_api_server(self, timeout=10):
        """检查API服务器是否可用"""
        try:
            response = requests.get(f"{API_BASE_URL}/status", timeout=timeout)
            if response.status_code == 200:
                status = response.json()
                return True, status
            else:
                return False, f"HTTP {response.status_code}"
        except requests.exceptions.Timeout:
            return False, "连接超时"
        except requests.exceptions.ConnectionError:
            return False, "连接拒绝"
        except Exception as e:
            return False, str(e)
    
    def _check_model_availability(self):
        """检查模型可用性"""
        # 首先检查简化的共享管理器状态
        status = simple_qwen.get_status()
        print(f"共享管理器状态: {status}")
        
        if status["external_model"]:
            print(f"✅ 检测到外部进程(PID: {status['external_pid']})已加载模型")
            
            # 检查API服务器是否可用
            api_available, api_status = self._check_api_server(timeout=10)
            if api_available:
                print("✅ API服务器可用，可以进行推理")
            else:
                print(f"⚠️ API服务器不可用: {api_status}")
                print("请确保 sample_audio.py 正在运行")
       
        else:
            print("⚠️ 未检测到已加载的模型")
            print("请先运行 sample_audio.py 加载模型")
    
    def _call_api(self, prompt: str, max_new_tokens: int = 512, retries=3) -> str:
        """调用API进行推理，带重试机制"""
        
        for attempt in range(retries):
            try:
                print(f"📡 发送API请求 (尝试 {attempt + 1}/{retries})")
                
                data = {
                    "prompt": prompt,
                    "max_new_tokens": max_new_tokens
                }
                
                # 增加超时时间
                response = requests.post(
                    f"{API_BASE_URL}/generate",
                    json=data,
                    timeout=180  # 3分钟超时
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if result.get("status") == "success":
                        print("✅ API请求成功")
                        return result.get("result", "")
                    else:
                        error_msg = result.get('error', 'Unknown error')
                        print(f"❌ API返回错误: {error_msg}")
                        if attempt < retries - 1:
                            print(f"🔄 {5}秒后重试...")
                            time.sleep(5)
                            continue
                        return f"API Error: {error_msg}"
                else:
                    error_msg = f"HTTP {response.status_code}"
                    print(f"❌ HTTP错误: {error_msg}")
                    if attempt < retries - 1:
                        print(f"🔄 {3}秒后重试...")
                        time.sleep(3)
                        continue
                    return f"HTTP Error: {error_msg}"
                    
            except requests.exceptions.ConnectionError:
                error_msg = "无法连接到API服务器"
                print(f"❌ 连接错误: {error_msg}")
                if attempt < retries - 1:
                    print(f"🔄 {3}秒后重试...")
                    time.sleep(3)
                    continue
                return f"Error: {error_msg}。请确保 sample_audio.py 正在运行。"
            except requests.exceptions.Timeout:
                error_msg = "API请求超时"
                print(f"❌ 超时错误: {error_msg}")
                if attempt < retries - 1:
                    print(f"🔄 {5}秒后重试...")
                    time.sleep(5)
                    continue
                return f"Error: {error_msg}"
            except Exception as e:
                error_msg = str(e)
                print(f"❌ 其他错误: {error_msg}")
                if attempt < retries - 1:
                    print(f"🔄 {3}秒后重试...")
                    time.sleep(3)
                    continue
                return f"Error: {error_msg}"
        
        return "Error: 所有重试都失败了"
    
    def generate(self, prompt: str, system_prompt: str = None, 
                history_messages: list = None, stream: bool = False, **kwargs) -> str:
        """生成回复（同步版本）"""
        try:
            # 构建完整的提示
            full_prompt = prompt
            if system_prompt:
                full_prompt = f"System: {system_prompt}\nUser: {prompt}"
            
            
            status = simple_qwen.get_status()
            
            # 使用API调用
            print("🔄 使用API推理...")
            return self._call_api(
                full_prompt,
                kwargs.get('max_new_tokens', self.config['max_new_tokens'])
            )
            
        except Exception as e:
            return f"Error: {str(e)}"
    
    async def agenerate(self, prompt: str, system_prompt: str = None, 
                   history_messages: list = None, stream: bool = False, **kwargs) -> str:
        if stream:
            # 这个分支实际上不会被 lightrag_bmodel2.py 调用，但保持逻辑完整
            raise NotImplementedError("Use agenerate_stream directly for streaming.")

        response_parts = []
        async for chunk in self.agenerate_stream(prompt, system_prompt, history_messages, **kwargs):
            response_parts.append(chunk)
        
        return "".join(response_parts)
    
    # 替换原有的 agenerate_stream
    async def agenerate_stream(self, prompt: str, system_prompt: str = None, 
                            history_messages: list = None, **kwargs) -> AsyncIterator[str]:
        full_prompt = prompt
        if system_prompt:
            full_prompt = f"System: {system_prompt}\nUser: {prompt}"
        
        data = {
            "prompt": full_prompt,
            "max_new_tokens": kwargs.get('max_new_tokens', self.config['max_new_tokens'])
        }

        loop = asyncio.get_running_loop()

        try:
            # 在线程池中运行同步的 requests 代码，避免阻塞事件循环
            def blocking_request():
                response = requests.post(
                    f"{API_BASE_URL}/generate",
                    json=data,
                    timeout=180,
                    stream=True  # 关键：开启流式请求
                )
                response.raise_for_status() # 如果HTTP状态码是4xx/5xx，则抛出异常
                return response.iter_content(chunk_size=None, decode_unicode=True)

            # iter_content 是一个同步迭代器，我们需要在异步函数中包装它
            sync_iterator = await loop.run_in_executor(None, blocking_request)
            
            for chunk in sync_iterator:
                yield chunk
                await asyncio.sleep(0) # 让出控制权，保持异步环境的响应性
        
        except requests.exceptions.RequestException as e:
            error_msg = f"Error during API stream request: {e}"
            print(error_msg)
            yield error_msg
        except Exception as e:
            yield f"Error: {str(e)}"

# 全局适配器实例
_global_llm_adapter: Optional[QwenLLMAdapter] = None

def get_qwen_llm_adapter(model_path: str = None,
                        config_path: str = None,
                        **kwargs) -> QwenLLMAdapter:
    """获取全局 LLM 适配器实例"""
    global _global_llm_adapter
    
    if _global_llm_adapter is None:
        config_kwargs = kwargs.copy()
        if model_path:
            config_kwargs["model_path"] = model_path
        if config_path:
            config_kwargs["config_path"] = config_path
            
        _global_llm_adapter = QwenLLMAdapter(**config_kwargs)
    
    return _global_llm_adapter

async def qwen_llm_model_func(prompt: str,
                             system_prompt: str = None,
                             history_messages: List = None,
                             keyword_extraction: bool = False,
                             stream: bool = False,
                             hashing_kv=None,
                             model_path: str = None,
                             config_path: str = None,
                             **kwargs) -> str:
    """LightRAG 兼容的 LLM 函数"""
    adapter = get_qwen_llm_adapter(
        model_path=model_path,
        config_path=config_path,
        **kwargs
    )
    
    if stream:
        async def stream_generator():
            async for chunk in adapter.agenerate_stream(
                prompt, system_prompt, history_messages, **kwargs
            ):
                yield chunk
        return stream_generator()
    else:
        return await adapter.agenerate(
            prompt, system_prompt, history_messages, stream, **kwargs
        )

async def test_streaming():
    print("🧪 测试异步流式生成...")
    adapter = get_qwen_llm_adapter()
    prompt = "简单介绍一下人工智能"
    print(f"Prompt: {prompt}")
    
    response_stream = adapter.agenerate_stream(prompt)
    async for chunk in response_stream:
        print(chunk, end="", flush=True)
    print("\n✅ 流式测试完成！")


if __name__ == "__main__":
           
    print("="*60)
    asyncio.run(test_streaming())
'''
'''pipelinef.py
import argparse
import chat
import time
from transformers import AutoTokenizer
import globalConfig

class Qwen2():

    def __init__(self, args):
        # devid
        self.devices = [int(d) for d in args.devid.split(",")]

        # load tokenizer
        print("Load " + args.config_path + " ...")
        self.tokenizer = AutoTokenizer.from_pretrained(args.config_path, trust_remote_code=True)

        # warm up
        self.tokenizer.decode([0])

        # preprocess parameters, such as prompt & tokenizer
        self.system_prompt = "You are a helpful assistant."
        self.history = [{"role": "system", "content": self.system_prompt}]
        self.EOS = self.tokenizer.eos_token_id
        self.enable_history = args.enable_history

        self.model = chat.Qwen()
        self.init_params(args)
        self.load_model(args.model_path)

    def load_model(self, model_path):
        load_start = time.time()
        self.model.init(self.devices, model_path)
        load_end = time.time()
        print(f"\nLoad Time: {(load_end - load_start):.3f} s")

    def init_params(self, args):
        self.model.temperature = args.temperature
        self.model.top_p = args.top_p
        self.model.repeat_penalty = args.repeat_penalty
        self.model.repeat_last_n = args.repeat_last_n
        self.model.max_new_tokens = args.max_new_tokens
        self.model.generation_mode = args.generation_mode

    def clear(self):
        self.history = [{"role": "system", "content": self.system_prompt}]

    def update_history(self):
        if self.model.token_length >= self.model.SEQLEN:
            print("... (reach the maximal length)", flush=True, end="")
            self.history = [{"role": "system", "content": self.system_prompt}]
        else:
            self.history.append({"role": "assistant", "content": self.answer_cur})

    def encode_tokens(self, content):
        """普通文本对话编码 - 用于 LightRAG"""
        # 为 LightRAG 使用简单的对话模板
        history = [
            {"role": "system", "content": "你是一个有用的AI助手，请简洁明了地回答问题。"},
            {"role": "user", "content": content}
        ]
        
        text = self.tokenizer.apply_chat_template(
            history,
            tokenize=False,
            add_generation_prompt=True,
            enable_thinking=False  # 明确关闭 think 模式
        )
        
        tokens = self.tokenizer(text).input_ids
        return tokens
    
    def encode_tokens_mermaid(self, content):
        """专门用于思维导图生成的编码方法"""
        template = f'''
<|im_start|>system\n你是一个Mermaid代码生成专家，用户将输入一段录音的语音识别结果，请你详细的总结并绘制一张思维导图，用Mermaid形式，生成符合语法的Mermaid代码。要求：\n1. 仅输出标准Mermaid代码，不包含任何解释或注释；\n2. 节点名称需用中文，但语法关键字（如graph TD、-->）保持英文；\n3. 严格遵循Mermaid语法规范。\n\n注意语法细节：\n- 节点定义格式：节点名[中文标签]，如 A[用户登录]\n- 连接符：使用 -->、---、==>|文字|== 等标准符号\n- 子图需用subgraph包裹并正确闭合\n- 方括号中的文字（即节点标签）内容请用引号包裹\n- 节点名称请使用不会与mermaid语法发生冲突的无意义内容，节点需要显示的内容请放在节点标签（即名称后的中括号）中\n\n*请确保你生成的是Mermaid代码!你只需要生成Mermaid代码，请不要附加其他信息!Mermaid代码请放到代码块中!*\n\n语音识别结果如下：\n<|im_end|>\n<|im_start|>user\n
{content}
\n<|im_end|>\n<|im_start|>system\n现在请你将上述内容详细的总结并绘制一张思维导图，用Mermaid形式，生成符合语法的Mermaid代码。要求：\n1. 仅输出标准Mermaid代码，不包含任何解释或注释；\n2. 节点名称需用中文，但语法关键字（如graph TD、-->）保持英文；\n3. 严格遵循Mermaid语法规范。\n\n注意语法细节：\n- 节点定义格式：节点名[\"中文标签\"]，如 A[\"用户登录\"]\n- 连接符：使用 -->、---、==>|文字|== 等标准符号\n- 子图需用subgraph包裹并正确闭合\n- 方括号中的文字（即节点标签）请用引号包裹\n- 节点名称请使用不会与mermaid语法发生冲突的无意义内容，节点需要显示的内容请放在节点标签（即名称后的中括号）中\n\n*请确保你生成的是Mermaid代码!你只需要生成Mermaid代码，请不要附加其他信息!Mermaid代码请放到代码块中!节点标签中的文字请使用英文引号\"\"包裹!*<|im_end|>\n<|im_start|>assistant\n<think>\n\n</think>\n\n
'''
        tokens = self.tokenizer(template.format(content = content),
                                padding=False,  # "longest",  # "max_length",
                                truncation=True,
                                max_length=5000,
                                return_special_tokens_mask=True).input_ids
        return tokens

    def chat(self, content, maxWord = 100000):
        """专门用于思维导图生成的聊天方法"""
        tokens = self.encode_tokens_mermaid(content)
        
        # check tokens
        if not tokens:
            print("Sorry: your question is empty!!")
            return
        if len(tokens) > self.model.SEQLEN:
            print(
                "The maximum question length should be shorter than {} but we get {} instead."
                .format(self.model.SEQLEN, len(tokens)))
            return
        print("\nAnswer: ", end="")
        return self.stream_answer(tokens, maxWord)
    
    def generate_text(self, content, maxWord = 1024):
        """普通文本生成方法 - 用于 LightRAG"""
        tokens = self.encode_tokens(content)
        
        # check tokens
        if not tokens:
            print("Sorry: your question is empty!!")
            return "Error: Empty input"
        if len(tokens) > self.model.SEQLEN:
            print(
                "The maximum question length should be shorter than {} but we get {} instead."
                .format(self.model.SEQLEN, len(tokens)))
            return f"Error: Input too long ({len(tokens)} tokens > {self.model.SEQLEN})"
        
        # return self.stream_answer_RAG(tokens, maxWord)
        yield from self.stream_answer_RAG(tokens, maxWord)

    def stream_answer(self, tokens , maxWord = 100000):
        """
        Stream the answer for the given tokens.
        """
        tok_num = 0
        self.answer_cur = ""
        self.answer_token = []

        # First token
        first_start = time.time()
        token = self.model.forward_first(tokens)
        first_end = time.time()
        # Following tokens
        full_word_tokens = []
        last_state = True
        last_state_token = 0
        while token != self.EOS and self.model.token_length < self.model.SEQLEN:
            full_word_tokens.append(token)
            word = self.tokenizer.decode(full_word_tokens, skip_special_tokens=True)
            if " " in word:
                token = self.model.forward_next()
                tok_num += 1
                continue
            self.answer_token += full_word_tokens
            print(word, flush=True, end="")
            # print(repr(word), flush=True, end="")
            tok_num += 1
            full_word_tokens = []
            token = self.model.forward_next()

            if(last_state and not globalConfig.running):
                last_state_token = tok_num
                last_state = False
            # is_newline = (word == '\n')
            # print(f"\n {is_newline}yes{tok_num} tokens {last_state_token} last_state_tok {last_state}||{globalConfig.running}")
            if((tok_num > maxWord or not globalConfig.running)and "\n" in word):
                print("...find \n (reach the maximal length)", flush=True, end="")#可能存在bug不过考虑到\n一般出现在最后
                break
            if(tok_num -last_state_token > 50 and not globalConfig.running):
                print("... (reach the maximal length break)", flush=True, end="")
                break
            if(tok_num > maxWord+50):
                print("... (reach the maximal length)", flush=True, end="")
                break
            

        # counting time
        next_end = time.time()
        first_duration = first_end - first_start
        next_duration = next_end - first_end
        tps = tok_num / next_duration


        if self.enable_history:
            self.answer_cur = self.tokenizer.decode(self.answer_token)
            self.update_history()
        else:
            self.clear()
        
        print()
        print(f"FTL: {first_duration:.3f} s")
        print(f"TPS: {tps:.3f} token/s")
        return self.tokenizer.decode(self.answer_token)

    def stream_answer_RAG(self, tokens, maxWord=100000):
        """
        Stream the answer for the given tokens. (修正版)
        """
        # 初始化部分保持不变
        tok_num = 0
        first_start = time.time()
        token = self.model.forward_first(tokens)
        first_end = time.time()

        # Following tokens
        full_word_tokens = []
        
        while token != self.EOS and self.model.token_length < self.model.SEQLEN:
            # 1. 累加当前的 token
            full_word_tokens.append(token)
            # 2. 尝试解码
            word = self.tokenizer.decode(full_word_tokens, skip_special_tokens=True)

            # 3. 检查解码是否完整。如果包含替换字符' '，说明是部分解码，
            #    需要获取更多token才能组成一个完整的字符。
            if " " in word:
                # 如果不完整，则获取下一个token，然后继续下一次循环以累加
                token = self.model.forward_next()
                tok_num += 1
                continue

            # 4. 如果代码能执行到这里，说明'word'是一个可读的、完整的片段。
            #    我们将其产出。
            yield word
            
            # 5. 重置 token 缓冲区，为下一个词做准备
            full_word_tokens = []

            # 6. 【关键】为下一次循环获取新的 token
            token = self.model.forward_next()
            tok_num += 1

        # 循环结束后，可以打印一些统计信息，但这对于流式函数不是必需的
        next_end = time.time()
        first_duration = first_end - first_start
        next_duration = next_end - first_end
        if next_duration > 0:
            tps = tok_num / next_duration
            print(f"\nFTL: {first_duration:.3f} s, TPS: {tps:.3f} token/s")

        # 对于生成器，不需要返回任何值，也不需要处理 history

def main():
    # 固定参数，无需命令行解析
    class Args:
        model_path = "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel"
        config_path = "config"
        devid = "0"
        temperature = 1.0
        top_p = 1.0
        repeat_penalty = 1.2
        repeat_last_n = 64
        max_new_tokens = 1024
        generation_mode = "greedy"
        prompt_mode = "prompted"
        enable_history = False  # 或 False，根据需要

    args = Args()
    model = Qwen2(args)
    print("--- 开始测试流式输出 ---")
    # 调用现在是生成器的 generate_text
    text_generator = model.generate_text("你好，请介绍一下你自己。")
    for word in text_generator:
        print(word, end="", flush=True)
    print("\n--- 测试结束 ---")


if __name__ == "__main__":
    main()
'''
'''globalConfig.py
import time
import json
# 控制线程运行的标志
running = True
qwen_interval = 30  # Qwen生成时间间隔，秒

CONFIG_PATH = "/data/mermaidRender/dist/config.json"

def load_config():
    """从配置文件读取配置，返回字典"""
    try:
        with open(CONFIG_PATH, "r") as f:
            config = json.load(f)
        return config
    except Exception as e:
        print(f"读取配置文件失败: {e}")
        return {}

def config_watcher():
    """配置文件监控线程，实时更新全局配置变量"""
    global running, qwen_interval
    last_config = {}
    print("配置监控线程已启动...")
    while True:
        config = load_config()
        if config != last_config:
            if "running" in config:
                running = bool(config["running"])
                print(f"配置更新: running = {running}")
            if "qwen_interval" in config:
                qwen_interval = float(config["qwen_interval"])
                print(f"配置更新: qwen_interval = {qwen_interval}")
            last_config = config
        time.sleep(1)  # 每秒检查一次
'''