
ä¹‹å‰èƒ½å¤ŸæˆåŠŸè¿è¡Œçš„æ—§ç‰ˆæœ¬ï¼ˆæ²¡æœ‰å®Œæˆå¯¹3æ¡éœ€æ±‚çš„æ»¡è¶³ï¼‰ï¼š
'''qwen_llm_adpter.py
"""
Qwen LLM bmodel é€‚é…å™¨ - ä½¿ç”¨HTTP APIè®¿é—®è¿œç¨‹æ¨¡å‹
ä¸º LightRAG æä¾›æœ¬åœ° Qwen bmodel æ¨ç†æ¥å£
"""
import sys
import os
import asyncio
import signal
import requests
import json
import time
from typing import List, Optional, AsyncIterator

# å¯¼å…¥ç®€åŒ–çš„å…±äº«ç®¡ç†å™¨ç”¨äºçŠ¶æ€æ£€æŸ¥
sys.path.append('/data/whisper-TPU_py/bmwhisper')
from shared_qwen_manager import simple_qwen

# ============ æ¨¡å‹è·¯å¾„é…ç½® ============
MODEL_CONFIG = {
    "llm_model_path": "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel",
    "config_path": "/data/LLM-TPU/models/Qwen3/python_demo/config",
    "device_id": "0",
    "temperature": 0.5,
    "top_p": 1.0,
    "repeat_penalty": 1.0,
    "repeat_last_n": 32,
    "max_new_tokens": 512,
    "generation_mode": "greedy"
}
# =====================================

# APIé…ç½®
API_BASE_URL = "http://localhost:8899"

class QwenLLMAdapter:
    """Qwen LLM bmodel é€‚é…å™¨ç±» - é€šè¿‡HTTP APIè®¿é—®æ¨¡å‹"""
    
    def __init__(self, **kwargs):
        self.config = {
            "model_path": kwargs.get("model_path", MODEL_CONFIG["llm_model_path"]),
            "config_path": kwargs.get("config_path", MODEL_CONFIG["config_path"]),
            "device_id": kwargs.get("device_id", MODEL_CONFIG["device_id"]),
            "temperature": kwargs.get("temperature", MODEL_CONFIG["temperature"]),
            "top_p": kwargs.get("top_p", MODEL_CONFIG["top_p"]),
            "repeat_penalty": kwargs.get("repeat_penalty", MODEL_CONFIG["repeat_penalty"]),
            "repeat_last_n": kwargs.get("repeat_last_n", MODEL_CONFIG["repeat_last_n"]),
            "max_new_tokens": kwargs.get("max_new_tokens", MODEL_CONFIG["max_new_tokens"]),
            "generation_mode": kwargs.get("generation_mode", MODEL_CONFIG["generation_mode"]),
            "prompt_mode": "prompted",
            "enable_history": False
        }
        
        self._check_model_availability()
    
    def _check_api_server(self, timeout=10):
        """æ£€æŸ¥APIæœåŠ¡å™¨æ˜¯å¦å¯ç”¨"""
        try:
            response = requests.get(f"{API_BASE_URL}/status", timeout=timeout)
            if response.status_code == 200:
                status = response.json()
                return True, status
            else:
                return False, f"HTTP {response.status_code}"
        except requests.exceptions.Timeout:
            return False, "è¿æ¥è¶…æ—¶"
        except requests.exceptions.ConnectionError:
            return False, "è¿æ¥æ‹’ç»"
        except Exception as e:
            return False, str(e)
    
    def _check_model_availability(self):
        """æ£€æŸ¥æ¨¡å‹å¯ç”¨æ€§"""
        # é¦–å…ˆæ£€æŸ¥ç®€åŒ–çš„å…±äº«ç®¡ç†å™¨çŠ¶æ€
        status = simple_qwen.get_status()
        print(f"å…±äº«ç®¡ç†å™¨çŠ¶æ€: {status}")
        
        if status["external_model"]:
            print(f"âœ… æ£€æµ‹åˆ°å¤–éƒ¨è¿›ç¨‹(PID: {status['external_pid']})å·²åŠ è½½æ¨¡å‹")
            
            # æ£€æŸ¥APIæœåŠ¡å™¨æ˜¯å¦å¯ç”¨
            api_available, api_status = self._check_api_server(timeout=10)
            if api_available:
                print("âœ… APIæœåŠ¡å™¨å¯ç”¨ï¼Œå¯ä»¥è¿›è¡Œæ¨ç†")
            else:
                print(f"âš ï¸ APIæœåŠ¡å™¨ä¸å¯ç”¨: {api_status}")
                print("è¯·ç¡®ä¿ sample_audio.py æ­£åœ¨è¿è¡Œ")
        elif status["local_model"]:
            print("âœ… æœ¬åœ°æ¨¡å‹å·²åŠ è½½ï¼Œå¯ä»¥ç›´æ¥æ¨ç†")
        else:
            print("âš ï¸ æœªæ£€æµ‹åˆ°å·²åŠ è½½çš„æ¨¡å‹")
            print("è¯·å…ˆè¿è¡Œ sample_audio.py åŠ è½½æ¨¡å‹")
    
    def _call_api(self, prompt: str, max_new_tokens: int = 512, retries=3) -> str:
        """è°ƒç”¨APIè¿›è¡Œæ¨ç†ï¼Œå¸¦é‡è¯•æœºåˆ¶"""
        
        for attempt in range(retries):
            try:
                print(f"ğŸ“¡ å‘é€APIè¯·æ±‚ (å°è¯• {attempt + 1}/{retries})")
                
                data = {
                    "prompt": prompt,
                    "max_new_tokens": max_new_tokens
                }
                
                # å¢åŠ è¶…æ—¶æ—¶é—´
                response = requests.post(
                    f"{API_BASE_URL}/generate",
                    json=data,
                    timeout=180  # 3åˆ†é’Ÿè¶…æ—¶
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if result.get("status") == "success":
                        print("âœ… APIè¯·æ±‚æˆåŠŸ")
                        return result.get("result", "")
                    else:
                        error_msg = result.get('error', 'Unknown error')
                        print(f"âŒ APIè¿”å›é”™è¯¯: {error_msg}")
                        if attempt < retries - 1:
                            print(f"ğŸ”„ {5}ç§’åé‡è¯•...")
                            time.sleep(5)
                            continue
                        return f"API Error: {error_msg}"
                else:
                    error_msg = f"HTTP {response.status_code}"
                    print(f"âŒ HTTPé”™è¯¯: {error_msg}")
                    if attempt < retries - 1:
                        print(f"ğŸ”„ {3}ç§’åé‡è¯•...")
                        time.sleep(3)
                        continue
                    return f"HTTP Error: {error_msg}"
                    
            except requests.exceptions.ConnectionError:
                error_msg = "æ— æ³•è¿æ¥åˆ°APIæœåŠ¡å™¨"
                print(f"âŒ è¿æ¥é”™è¯¯: {error_msg}")
                if attempt < retries - 1:
                    print(f"ğŸ”„ {3}ç§’åé‡è¯•...")
                    time.sleep(3)
                    continue
                return f"Error: {error_msg}ã€‚è¯·ç¡®ä¿ sample_audio.py æ­£åœ¨è¿è¡Œã€‚"
            except requests.exceptions.Timeout:
                error_msg = "APIè¯·æ±‚è¶…æ—¶"
                print(f"âŒ è¶…æ—¶é”™è¯¯: {error_msg}")
                if attempt < retries - 1:
                    print(f"ğŸ”„ {5}ç§’åé‡è¯•...")
                    time.sleep(5)
                    continue
                return f"Error: {error_msg}"
            except Exception as e:
                error_msg = str(e)
                print(f"âŒ å…¶ä»–é”™è¯¯: {error_msg}")
                if attempt < retries - 1:
                    print(f"ğŸ”„ {3}ç§’åé‡è¯•...")
                    time.sleep(3)
                    continue
                return f"Error: {error_msg}"
        
        return "Error: æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†"
    
    def generate(self, prompt: str, system_prompt: str = None, 
                history_messages: list = None, stream: bool = False, **kwargs) -> str:
        """ç”Ÿæˆå›å¤ï¼ˆåŒæ­¥ç‰ˆæœ¬ï¼‰"""
        try:
            # æ„å»ºå®Œæ•´çš„æç¤º
            full_prompt = prompt
            if system_prompt:
                full_prompt = f"System: {system_prompt}\nUser: {prompt}"
            
            # é¦–å…ˆå°è¯•ç›´æ¥ä½¿ç”¨æœ¬åœ°æ¨¡å‹
            status = simple_qwen.get_status()
            if status["local_model"]:
                print("ğŸ”„ ä½¿ç”¨æœ¬åœ°æ¨¡å‹æ¨ç†...")
                try:
                    from shared_qwen_manager import generate_text
                    result = generate_text(
                        full_prompt,
                        kwargs.get('max_new_tokens', self.config['max_new_tokens'])
                    )
                    return result
                except Exception as e:
                    print(f"âš ï¸ æœ¬åœ°æ¨¡å‹æ¨ç†å¤±è´¥ï¼Œå°è¯•API: {e}")
            
            # ä½¿ç”¨APIè°ƒç”¨
            print("ğŸ”„ ä½¿ç”¨APIæ¨ç†...")
            return self._call_api(
                full_prompt,
                kwargs.get('max_new_tokens', self.config['max_new_tokens'])
            )
            
        except Exception as e:
            return f"Error: {str(e)}"
    
    async def agenerate(self, prompt: str, system_prompt: str = None, 
                       history_messages: list = None, stream: bool = False, **kwargs) -> str:
        """å¼‚æ­¥ç”Ÿæˆå›å¤"""
        # åœ¨å¼‚æ­¥ç¯å¢ƒä¸­è°ƒç”¨åŒæ­¥æ–¹æ³•
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None, 
            self.generate, 
            prompt, 
            system_prompt, 
            history_messages, 
            stream, 
            **kwargs
        )
    
    async def agenerate_stream(self, prompt: str, system_prompt: str = None, 
                              history_messages: list = None, **kwargs) -> AsyncIterator[str]:
        """å¼‚æ­¥æµå¼ç”Ÿæˆï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰"""
        try:
            result = await self.agenerate(prompt, system_prompt, history_messages, **kwargs)
            
            if result.startswith("Error:"):
                yield result
                return
            
            words = result.split()
            for i, word in enumerate(words):
                if i == 0:
                    yield word
                else:
                    yield " " + word
                await asyncio.sleep(0.01)
                
        except Exception as e:
            yield f"Error: {str(e)}"

# å…¨å±€é€‚é…å™¨å®ä¾‹
_global_llm_adapter: Optional[QwenLLMAdapter] = None

def get_qwen_llm_adapter(model_path: str = None,
                        config_path: str = None,
                        **kwargs) -> QwenLLMAdapter:
    """è·å–å…¨å±€ LLM é€‚é…å™¨å®ä¾‹"""
    global _global_llm_adapter
    
    if _global_llm_adapter is None:
        config_kwargs = kwargs.copy()
        if model_path:
            config_kwargs["model_path"] = model_path
        if config_path:
            config_kwargs["config_path"] = config_path
            
        _global_llm_adapter = QwenLLMAdapter(**config_kwargs)
    
    return _global_llm_adapter

async def qwen_llm_model_func(prompt: str,
                             system_prompt: str = None,
                             history_messages: List = None,
                             keyword_extraction: bool = False,
                             stream: bool = False,
                             hashing_kv=None,
                             model_path: str = None,
                             config_path: str = None,
                             **kwargs) -> str:
    """LightRAG å…¼å®¹çš„ LLM å‡½æ•°"""
    adapter = get_qwen_llm_adapter(
        model_path=model_path,
        config_path=config_path,
        **kwargs
    )
    
    if stream:
        async def stream_generator():
            async for chunk in adapter.agenerate_stream(
                prompt, system_prompt, history_messages, **kwargs
            ):
                yield chunk
        return stream_generator()
    else:
        return await adapter.agenerate(
            prompt, system_prompt, history_messages, stream, **kwargs
        )

def test_shared_manager_status():
    """æµ‹è¯•å…±äº«ç®¡ç†å™¨çŠ¶æ€"""
    print("ğŸ” æ£€æŸ¥å…±äº«ç®¡ç†å™¨çŠ¶æ€...")
    try:
        status = simple_qwen.get_status()
        print(f"ç®¡ç†å™¨çŠ¶æ€: {status}")
        
        if status["local_model"]:
            print("âœ… æœ¬åœ°æ¨¡å‹å·²åŠ è½½")
        elif status["external_model"]:
            print(f"âœ… å¤–éƒ¨æ¨¡å‹å·²åŠ è½½ (PID: {status['external_pid']})")
        else:
            print("âš ï¸ æœªæ£€æµ‹åˆ°å·²åŠ è½½çš„æ¨¡å‹")
            
        return status["model_loaded"]
    except Exception as e:
        print(f"âŒ æ£€æŸ¥çŠ¶æ€å¤±è´¥: {e}")
        return False

def test_qwen_llm_adapter():
    """æµ‹è¯• Qwen LLM é€‚é…å™¨"""
    print("ğŸ§ª æµ‹è¯• Qwen LLM bmodel é€‚é…å™¨...")
    
    try:
        if not test_shared_manager_status():
            print("âš ï¸ å…±äº«ç®¡ç†å™¨çŠ¶æ€å¼‚å¸¸ï¼Œä½†ç»§ç»­æµ‹è¯•...")
        
        adapter = get_qwen_llm_adapter()
        
        print("ğŸ“ æµ‹è¯•åŒæ­¥ç”Ÿæˆ...")
        print("æç¤ºï¼šè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…...")
        
        response = adapter.generate(
            "ç®€å•ä»‹ç»ä¸€ä¸‹äººå·¥æ™ºèƒ½",
            system_prompt="ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„åŠ©æ‰‹ï¼Œè¯·ç®€æ´å›ç­”ã€‚"
        )
        
        print(f"åŒæ­¥ç”Ÿæˆå›å¤: {response[:200]}...")
        
        if response and not response.startswith("Error:"):
            print("âœ… Qwen LLM é€‚é…å™¨åŒæ­¥æµ‹è¯•é€šè¿‡ï¼")
            return True
        else:
            print("âŒ åŒæ­¥æµ‹è¯•å¤±è´¥æˆ–è¿”å›é”™è¯¯")
            print(f"å®Œæ•´å›å¤: {response}")
            return False
        
    except Exception as e:
        print(f"âŒ Qwen LLM é€‚é…å™¨æµ‹è¯•å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    try:
        print("ğŸš€ å¯åŠ¨ Qwen LLM é€‚é…å™¨æµ‹è¯•å¥—ä»¶...")
        print("=" * 60)
        
        sync_success = test_qwen_llm_adapter()
        print("-" * 60)
        
        if sync_success:
            print("\nğŸ‰ æµ‹è¯•é€šè¿‡ï¼é€‚é…å™¨å¯ä»¥æ­£ç¡®ä½¿ç”¨æ¨¡å‹ã€‚")
        else:
            print("\nâš ï¸ æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥:")
            print("  1. sample_audio.py æ˜¯å¦æ­£åœ¨è¿è¡Œ")
            print("  2. æ¨¡å‹æ˜¯å¦æ­£å¿™ç¢Œ (ç­‰å¾…å½“å‰ä»»åŠ¡å®Œæˆ)")
            print("  3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸")
        
    except KeyboardInterrupt:
        print("\nğŸ”„ ç”¨æˆ·ä¸­æ–­ï¼Œç¨‹åºé€€å‡º")
    except Exception as e:
        print(f"\nâŒ ç¨‹åºå¼‚å¸¸: {e}")
'''
'''shared_qwen_manager.py
import os
import json
import threading
from typing import Optional
from pipelinef import Qwen2

class SimpleQwenManager:
    """ç®€åŒ–çš„ Qwen æ¨¡å‹ç®¡ç†å™¨ - ä»…ç”¨äºæœ¬åœ°ç®¡ç†"""
    
    _instance: Optional['SimpleQwenManager'] = None
    _lock = threading.Lock()
    
    # çŠ¶æ€æ–‡ä»¶
    STATUS_FILE = "/tmp/qwen_model_status.json"
    
    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._initialized = False
            return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
            
        self.model: Optional[Qwen2] = None
        self.model_lock = threading.RLock()
        self._initialized = True
    
    def _write_status_file(self, status):
        """å†™å…¥çŠ¶æ€æ–‡ä»¶"""
        try:
            with open(self.STATUS_FILE, 'w') as f:
                json.dump(status, f, indent=2)
        except Exception as e:
            print(f"å†™å…¥çŠ¶æ€æ–‡ä»¶å¤±è´¥: {e}")
    
    def _read_status_file(self):
        """è¯»å–çŠ¶æ€æ–‡ä»¶"""
        try:
            if os.path.exists(self.STATUS_FILE):
                with open(self.STATUS_FILE, 'r') as f:
                    return json.load(f)
        except:
            pass
        return {"model_loaded": False, "pid": None, "model_path": None}
    
    def initialize_model(self, args):
        """åˆå§‹åŒ–æ¨¡å‹"""
        with self.model_lock:
            if self.model is None:
                print("ğŸ”„ åˆå§‹åŒ– Qwen æ¨¡å‹...")
                self.model = Qwen2(args)
                
                # æ›´æ–°çŠ¶æ€æ–‡ä»¶
                status = {
                    "model_loaded": True,
                    "pid": os.getpid(),
                    "model_path": args.model_path,
                    "timestamp": __import__('time').time()
                }
                self._write_status_file(status)
                
                print("âœ… Qwen æ¨¡å‹åˆå§‹åŒ–å®Œæˆ")
            else:
                print("âœ… æ¨¡å‹å·²ç»åŠ è½½")
    
    def get_model(self):
        """è·å–æ¨¡å‹å®ä¾‹"""
        return self.model
    
    def is_loaded(self):
        """æ£€æŸ¥æ¨¡å‹æ˜¯å¦å·²åŠ è½½"""
        return self.model is not None
    
    def get_status(self):
        """è·å–çŠ¶æ€ï¼ˆä¸»è¦ç”¨äºå…¼å®¹æ€§ï¼‰"""
        status = self._read_status_file()
        return {
            "model_loaded": self.model is not None,
            "local_model": self.model is not None,
            "external_model": status.get("model_loaded", False) and status.get("pid") != os.getpid(),
            "external_pid": status.get("pid"),
            "current_pid": os.getpid()
        }
    
    def shutdown(self):
        """å…³é—­ç®¡ç†å™¨"""
        if self.model is not None:
            print("ğŸ”„ æ¸…ç†æ¨¡å‹çŠ¶æ€...")
            self._write_status_file({"model_loaded": False, "pid": None, "model_path": None})
        print("âœ… æ¨¡å‹ç®¡ç†å™¨å·²å…³é—­")

# å…¨å±€å•ä¾‹
simple_qwen = SimpleQwenManager()

# ç®€åŒ–çš„ä»»åŠ¡å‡½æ•°
def generate_mermaid(text, maxWord):
    """æ€ç»´å¯¼å›¾ç”Ÿæˆ"""
    if simple_qwen.model:
        return simple_qwen.model.chat(text, maxWord)
    else:
        raise RuntimeError("æ¨¡å‹æœªåŠ è½½")

def generate_text(prompt, max_new_tokens=512):
    """æ–‡æœ¬ç”Ÿæˆ"""
    if simple_qwen.model:
        return simple_qwen.model.generate_text(prompt, max_new_tokens)
    else:
        raise RuntimeError("æ¨¡å‹æœªåŠ è½½")
'''
'''pipelinef.py
import argparse
import chat
import time
from transformers import AutoTokenizer
import globalConfig

class Qwen2():

    def __init__(self, args):
        # devid
        self.devices = [int(d) for d in args.devid.split(",")]

        # load tokenizer
        print("Load " + args.config_path + " ...")
        self.tokenizer = AutoTokenizer.from_pretrained(args.config_path, trust_remote_code=True)

        # warm up
        self.tokenizer.decode([0])

        # preprocess parameters, such as prompt & tokenizer
        self.system_prompt = "You are a helpful assistant."
        self.history = [{"role": "system", "content": self.system_prompt}]
        self.EOS = self.tokenizer.eos_token_id
        self.enable_history = args.enable_history

        self.model = chat.Qwen()
        self.init_params(args)
        self.load_model(args.model_path)

    def load_model(self, model_path):
        load_start = time.time()
        self.model.init(self.devices, model_path)
        load_end = time.time()
        print(f"\nLoad Time: {(load_end - load_start):.3f} s")

    def init_params(self, args):
        self.model.temperature = args.temperature
        self.model.top_p = args.top_p
        self.model.repeat_penalty = args.repeat_penalty
        self.model.repeat_last_n = args.repeat_last_n
        self.model.max_new_tokens = args.max_new_tokens
        self.model.generation_mode = args.generation_mode

    def clear(self):
        self.history = [{"role": "system", "content": self.system_prompt}]

    def update_history(self):
        if self.model.token_length >= self.model.SEQLEN:
            print("... (reach the maximal length)", flush=True, end="")
            self.history = [{"role": "system", "content": self.system_prompt}]
        else:
            self.history.append({"role": "assistant", "content": self.answer_cur})

    def encode_tokens(self, content):
        """æ™®é€šæ–‡æœ¬å¯¹è¯ç¼–ç  - ç”¨äº LightRAG"""
        # ä¸º LightRAG ä½¿ç”¨ç®€å•çš„å¯¹è¯æ¨¡æ¿
        history = [
            {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„AIåŠ©æ‰‹ï¼Œè¯·ç®€æ´æ˜äº†åœ°å›ç­”é—®é¢˜ã€‚"},
            {"role": "user", "content": content}
        ]
        
        text = self.tokenizer.apply_chat_template(
            history,
            tokenize=False,
            add_generation_prompt=True,
            enable_thinking=False  # æ˜ç¡®å…³é—­ think æ¨¡å¼
        )
        
        tokens = self.tokenizer(text).input_ids
        return tokens
    
    def encode_tokens_mermaid(self, content):
        """ä¸“é—¨ç”¨äºæ€ç»´å¯¼å›¾ç”Ÿæˆçš„ç¼–ç æ–¹æ³•"""
        template = f'''
<|im_start|>system\nä½ æ˜¯ä¸€ä¸ªMermaidä»£ç ç”Ÿæˆä¸“å®¶ï¼Œç”¨æˆ·å°†è¾“å…¥ä¸€æ®µå½•éŸ³çš„è¯­éŸ³è¯†åˆ«ç»“æœï¼Œè¯·ä½ è¯¦ç»†çš„æ€»ç»“å¹¶ç»˜åˆ¶ä¸€å¼ æ€ç»´å¯¼å›¾ï¼Œç”¨Mermaidå½¢å¼ï¼Œç”Ÿæˆç¬¦åˆè¯­æ³•çš„Mermaidä»£ç ã€‚è¦æ±‚ï¼š\n1. ä»…è¾“å‡ºæ ‡å‡†Mermaidä»£ç ï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šæˆ–æ³¨é‡Šï¼›\n2. èŠ‚ç‚¹åç§°éœ€ç”¨ä¸­æ–‡ï¼Œä½†è¯­æ³•å…³é”®å­—ï¼ˆå¦‚graph TDã€-->ï¼‰ä¿æŒè‹±æ–‡ï¼›\n3. ä¸¥æ ¼éµå¾ªMermaidè¯­æ³•è§„èŒƒã€‚\n\næ³¨æ„è¯­æ³•ç»†èŠ‚ï¼š\n- èŠ‚ç‚¹å®šä¹‰æ ¼å¼ï¼šèŠ‚ç‚¹å[ä¸­æ–‡æ ‡ç­¾]ï¼Œå¦‚ A[ç”¨æˆ·ç™»å½•]\n- è¿æ¥ç¬¦ï¼šä½¿ç”¨ -->ã€---ã€==>|æ–‡å­—|== ç­‰æ ‡å‡†ç¬¦å·\n- å­å›¾éœ€ç”¨subgraphåŒ…è£¹å¹¶æ­£ç¡®é—­åˆ\n- æ–¹æ‹¬å·ä¸­çš„æ–‡å­—ï¼ˆå³èŠ‚ç‚¹æ ‡ç­¾ï¼‰å†…å®¹è¯·ç”¨å¼•å·åŒ…è£¹\n- èŠ‚ç‚¹åç§°è¯·ä½¿ç”¨ä¸ä¼šä¸mermaidè¯­æ³•å‘ç”Ÿå†²çªçš„æ— æ„ä¹‰å†…å®¹ï¼ŒèŠ‚ç‚¹éœ€è¦æ˜¾ç¤ºçš„å†…å®¹è¯·æ”¾åœ¨èŠ‚ç‚¹æ ‡ç­¾ï¼ˆå³åç§°åçš„ä¸­æ‹¬å·ï¼‰ä¸­\n\n*è¯·ç¡®ä¿ä½ ç”Ÿæˆçš„æ˜¯Mermaidä»£ç !ä½ åªéœ€è¦ç”ŸæˆMermaidä»£ç ï¼Œè¯·ä¸è¦é™„åŠ å…¶ä»–ä¿¡æ¯!Mermaidä»£ç è¯·æ”¾åˆ°ä»£ç å—ä¸­!*\n\nè¯­éŸ³è¯†åˆ«ç»“æœå¦‚ä¸‹ï¼š\n<|im_end|>\n<|im_start|>user\n
{content}
\n<|im_end|>\n<|im_start|>system\nç°åœ¨è¯·ä½ å°†ä¸Šè¿°å†…å®¹è¯¦ç»†çš„æ€»ç»“å¹¶ç»˜åˆ¶ä¸€å¼ æ€ç»´å¯¼å›¾ï¼Œç”¨Mermaidå½¢å¼ï¼Œç”Ÿæˆç¬¦åˆè¯­æ³•çš„Mermaidä»£ç ã€‚è¦æ±‚ï¼š\n1. ä»…è¾“å‡ºæ ‡å‡†Mermaidä»£ç ï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šæˆ–æ³¨é‡Šï¼›\n2. èŠ‚ç‚¹åç§°éœ€ç”¨ä¸­æ–‡ï¼Œä½†è¯­æ³•å…³é”®å­—ï¼ˆå¦‚graph TDã€-->ï¼‰ä¿æŒè‹±æ–‡ï¼›\n3. ä¸¥æ ¼éµå¾ªMermaidè¯­æ³•è§„èŒƒã€‚\n\næ³¨æ„è¯­æ³•ç»†èŠ‚ï¼š\n- èŠ‚ç‚¹å®šä¹‰æ ¼å¼ï¼šèŠ‚ç‚¹å[\"ä¸­æ–‡æ ‡ç­¾\"]ï¼Œå¦‚ A[\"ç”¨æˆ·ç™»å½•\"]\n- è¿æ¥ç¬¦ï¼šä½¿ç”¨ -->ã€---ã€==>|æ–‡å­—|== ç­‰æ ‡å‡†ç¬¦å·\n- å­å›¾éœ€ç”¨subgraphåŒ…è£¹å¹¶æ­£ç¡®é—­åˆ\n- æ–¹æ‹¬å·ä¸­çš„æ–‡å­—ï¼ˆå³èŠ‚ç‚¹æ ‡ç­¾ï¼‰è¯·ç”¨å¼•å·åŒ…è£¹\n- èŠ‚ç‚¹åç§°è¯·ä½¿ç”¨ä¸ä¼šä¸mermaidè¯­æ³•å‘ç”Ÿå†²çªçš„æ— æ„ä¹‰å†…å®¹ï¼ŒèŠ‚ç‚¹éœ€è¦æ˜¾ç¤ºçš„å†…å®¹è¯·æ”¾åœ¨èŠ‚ç‚¹æ ‡ç­¾ï¼ˆå³åç§°åçš„ä¸­æ‹¬å·ï¼‰ä¸­\n\n*è¯·ç¡®ä¿ä½ ç”Ÿæˆçš„æ˜¯Mermaidä»£ç !ä½ åªéœ€è¦ç”ŸæˆMermaidä»£ç ï¼Œè¯·ä¸è¦é™„åŠ å…¶ä»–ä¿¡æ¯!Mermaidä»£ç è¯·æ”¾åˆ°ä»£ç å—ä¸­!èŠ‚ç‚¹æ ‡ç­¾ä¸­çš„æ–‡å­—è¯·ä½¿ç”¨è‹±æ–‡å¼•å·\"\"åŒ…è£¹!*<|im_end|>\n<|im_start|>assistant\n<think>\n\n</think>\n\n
'''
        tokens = self.tokenizer(template.format(content = content),
                                padding=False,  # "longest",  # "max_length",
                                truncation=True,
                                max_length=5000,
                                return_special_tokens_mask=True).input_ids
        return tokens

    def chat(self, content, maxWord = 100000):
        """ä¸“é—¨ç”¨äºæ€ç»´å¯¼å›¾ç”Ÿæˆçš„èŠå¤©æ–¹æ³•"""
        tokens = self.encode_tokens_mermaid(content)
        
        # check tokens
        if not tokens:
            print("Sorry: your question is empty!!")
            return
        if len(tokens) > self.model.SEQLEN:
            print(
                "The maximum question length should be shorter than {} but we get {} instead."
                .format(self.model.SEQLEN, len(tokens)))
            return
        print("\nAnswer: ", end="")
        return self.stream_answer(tokens, maxWord)
    
    def generate_text(self, content, maxWord = 1024):
        """æ™®é€šæ–‡æœ¬ç”Ÿæˆæ–¹æ³• - ç”¨äº LightRAG"""
        tokens = self.encode_tokens(content)
        
        # check tokens
        if not tokens:
            print("Sorry: your question is empty!!")
            return "Error: Empty input"
        if len(tokens) > self.model.SEQLEN:
            print(
                "The maximum question length should be shorter than {} but we get {} instead."
                .format(self.model.SEQLEN, len(tokens)))
            return f"Error: Input too long ({len(tokens)} tokens > {self.model.SEQLEN})"
        
        return self.stream_answer(tokens, maxWord)

    def stream_answer(self, tokens , maxWord = 100000):
        """
        Stream the answer for the given tokens.
        """
        tok_num = 0
        self.answer_cur = ""
        self.answer_token = []

        # First token
        first_start = time.time()
        token = self.model.forward_first(tokens)
        first_end = time.time()
        # Following tokens
        full_word_tokens = []
        last_state = True
        last_state_token = 0
        while token != self.EOS and self.model.token_length < self.model.SEQLEN:
            full_word_tokens.append(token)
            word = self.tokenizer.decode(full_word_tokens, skip_special_tokens=True)
            if " " in word:
                token = self.model.forward_next()
                tok_num += 1
                continue
            self.answer_token += full_word_tokens
            print(word, flush=True, end="")
            # print(repr(word), flush=True, end="")
            tok_num += 1
            full_word_tokens = []
            token = self.model.forward_next()

            if(last_state and not globalConfig.running):
                last_state_token = tok_num
                last_state = False
            # is_newline = (word == '\n')
            # print(f"\n {is_newline}yes{tok_num} tokens {last_state_token} last_state_tok {last_state}||{globalConfig.running}")
            if((tok_num > maxWord or not globalConfig.running)and "\n" in word):
                print("...find \n (reach the maximal length)", flush=True, end="")#å¯èƒ½å­˜åœ¨bugä¸è¿‡è€ƒè™‘åˆ°\nä¸€èˆ¬å‡ºç°åœ¨æœ€å
                break
            if(tok_num -last_state_token > 50 and not globalConfig.running):
                print("... (reach the maximal length break)", flush=True, end="")
                break
            if(tok_num > maxWord+50):
                print("... (reach the maximal length)", flush=True, end="")
                break
            

        # counting time
        next_end = time.time()
        first_duration = first_end - first_start
        next_duration = next_end - first_end
        tps = tok_num / next_duration


        if self.enable_history:
            self.answer_cur = self.tokenizer.decode(self.answer_token)
            self.update_history()
        else:
            self.clear()
        
        print()
        print(f"FTL: {first_duration:.3f} s")
        print(f"TPS: {tps:.3f} token/s")
        return self.tokenizer.decode(self.answer_token)

    ## For Web Demo
    def stream_predict(self, query):
        """
        Stream the prediction for the given query.
        """
        self.answer_cur = ""
        self.input_str = query
        tokens = self.encode_tokens()

        for answer_cur, history in self._generate_predictions(tokens):
            yield answer_cur, history

    def _generate_predictions(self, tokens):
        """
        Generate predictions for the given tokens.
        """
        # First token
        next_token = self.model.forward_first(tokens)
        output_tokens = [next_token]

        # Following tokens
        while True:
            next_token = self.model.forward_next()
            if next_token == self.EOS:
                break
            output_tokens += [next_token]
            self.answer_cur = self.tokenizer.decode(output_tokens)
            if self.model.token_length >= self.model.SEQLEN:
                self.update_history()
                yield self.answer_cur + "\n\n\nReached the maximum length; The history context has been cleared.", self.history
                break
            else:
                yield self.answer_cur, self.history

        self.update_history()


def main():
    # å›ºå®šå‚æ•°ï¼Œæ— éœ€å‘½ä»¤è¡Œè§£æ
    class Args:
        model_path = "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel"
        config_path = "config"
        devid = "0"
        temperature = 1.0
        top_p = 1.0
        repeat_penalty = 1.2
        repeat_last_n = 64
        max_new_tokens = 1024
        generation_mode = "greedy"
        prompt_mode = "prompted"
        enable_history = False  # æˆ– Falseï¼Œæ ¹æ®éœ€è¦

    args = Args()
    model = Qwen2(args)
    print(model.chat("ä½ æ˜¯è°"))


if __name__ == "__main__":
    main()
'''
'''sample_audio.py
import pyaudio
import wave
import threading
import queue
import os
import time
import json
from datetime import datetime
import globalConfig
import random
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import urllib.parse

# å¯¼å…¥ç®€åŒ–çš„å…±äº«ç®¡ç†å™¨
from shared_qwen_manager import simple_qwen, generate_mermaid, generate_text

# å‚æ•°è®¾ç½®
FORMAT = pyaudio.paInt16  # 16ä½é‡‡æ ·
CHANNELS = 1              # å•å£°é“
RATE = 16000              # é‡‡æ ·ç‡ï¼ˆHzï¼‰
CHUNK = 1024              # æ¯ä¸ªç¼“å†²åŒºçš„å¸§æ•°
RECORD_SECONDS = 30       # æ¯ä¸ªæ–‡ä»¶å½•éŸ³æ—¶é•¿
RECORDING_FOLDER = "recordings"  # å½•éŸ³æ–‡ä»¶ä¿å­˜æ–‡ä»¶å¤¹

# åˆ›å»ºä¿å­˜å½•éŸ³çš„æ–‡ä»¶å¤¹
os.makedirs(RECORDING_FOLDER, exist_ok=True)

# åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—ç”¨äºå­˜å‚¨å¾…å¤„ç†çš„éŸ³é¢‘æ–‡ä»¶
audio_queue = queue.Queue()

exitFlag = False

class QwenAPIHandler(BaseHTTPRequestHandler):
    """ç®€å•çš„HTTP APIå¤„ç†å™¨ï¼Œç”¨äºè·¨è¿›ç¨‹æ¨ç†"""
    
    def do_POST(self):
        if self.path == '/generate':
            try:
                # è¯»å–è¯·æ±‚æ•°æ®
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                data = json.loads(post_data.decode('utf-8'))
                
                prompt = data.get('prompt', '')
                max_new_tokens = data.get('max_new_tokens', 512)
                
                if not prompt:
                    self.send_error(400, "Missing prompt")
                    return
                
                # ä½¿ç”¨ç®€åŒ–çš„ä»»åŠ¡å‡½æ•°
                result = generate_text(prompt, max_new_tokens)
                
                # è¿”å›ç»“æœ
                response = {'result': result, 'status': 'success'}
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode('utf-8'))
                
            except Exception as e:
                error_response = {'error': str(e), 'status': 'error'}
                self.send_response(500)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(error_response).encode('utf-8'))
    
    def do_GET(self):
        if self.path == '/status':
            # è¿”å›æ¨¡å‹çŠ¶æ€
            status = simple_qwen.get_status()
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(status).encode('utf-8'))
        else:
            self.send_error(404, "Not found")
    
    def log_message(self, format, *args):
        # ç¦ç”¨é»˜è®¤æ—¥å¿—è¾“å‡º
        pass

def start_api_server():
    """å¯åŠ¨APIæœåŠ¡å™¨"""
    try:
        server = HTTPServer(('localhost', 8899), QwenAPIHandler)
        print("ğŸŒ APIæœåŠ¡å™¨å¯åŠ¨åœ¨ http://localhost:8899")
        print("  - POST /generate : æ–‡æœ¬ç”Ÿæˆ")
        print("  - GET /status : æ¨¡å‹çŠ¶æ€")
        server.serve_forever()
    except Exception as e:
        print(f"âŒ APIæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: {e}")

def initEnv():
    import os
    # è®¾ç½®ç¯å¢ƒå˜é‡
    os.environ["LOG_LEVEL"] = "-1"
    os.environ["LD_LIBRARY_PATH"] = "/opt/sophon/libsophon-current/lib:" + os.environ.get("LD_LIBRARY_PATH", "")

    # å¯åŠ¨ pulseaudioï¼ˆå¿½ç•¥é”™è¯¯ï¼‰
    os.system("pulseaudio --start 2>/dev/null || true")

def initMermaid(text):
    template = f"""
graph LR
    A[{text}å¼€å¯å…¨æ–°æ•™å­¦æ¨¡å¼] --> B[æ€ç»´å¯¼å›¾]
    A --> C[è¯¾æœ¬æŸ¥è¯¢]
    A --> D[äº’åŠ¨æé—®]
    A --> E[å†å²ç¬”è®°]
"""
    # Ensure the output directory exists
    os.makedirs('/data/mermaidRender/text', exist_ok=True)
    with open('/data/mermaidRender/text/outmermaid.mmd', "w") as f:
        f.write(template)

def record_audio():
    """å½•éŸ³çº¿ç¨‹ï¼šæŒç»­å½•éŸ³å¹¶æ¯10ç§’ä¿å­˜ä¸€ä¸ªæ–‡ä»¶"""
    # åˆå§‹åŒ–PyAudio
    audio = pyaudio.PyAudio()
    
    # æ‰“å¼€æµ
    stream = audio.open(format=FORMAT,
                        channels=CHANNELS,
                        rate=RATE,
                        input=True,
                        frames_per_buffer=CHUNK)
    
    print("å½•éŸ³çº¿ç¨‹å·²å¯åŠ¨")
    last_state = True
    try:
        while True:
            if exitFlag:
                print("record_audioçº¿ç¨‹é€€å‡º")
                break
            if not globalConfig.running:
                time.sleep(1)
                last_state = False
                continue
            # æ¸…ç©ºè¾“å…¥ç¼“å†²åŒºï¼Œé¿å…æ®‹ç•™æ•°æ®å½±å“æ–°å½•éŸ³
            if(not last_state):
                print("å½•éŸ³çº¿ç¨‹å¼€å§‹ï¼Œæ¸…ç©ºè¾“å…¥ç¼“å†²åŒº...")
                initMermaid("æ­£åœ¨é‡‡é›†ä¸­...")
                last_state = True
                stream.stop_stream()
                stream.start_stream()

            frames = []
            filename = os.path.join(
                RECORDING_FOLDER,
                f"audio_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}_{random.randint(1000,9999)}.wav"
            )
            print(f"å¼€å§‹å½•åˆ¶æ–‡ä»¶: {filename}")
            
            # å½•åˆ¶æŒ‡å®šç§’æ•°çš„éŸ³é¢‘
            for _ in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
                if not globalConfig.running:
                    break
                data = stream.read(CHUNK)
                frames.append(data)
            
            # ä¿å­˜ä¸ºWAVæ–‡ä»¶
            if frames:  # ç¡®ä¿æœ‰æ•°æ®å†ä¿å­˜
                wf = wave.open(filename, 'wb')
                wf.setnchannels(CHANNELS)
                wf.setsampwidth(audio.get_sample_size(FORMAT))
                wf.setframerate(RATE)
                wf.writeframes(b''.join(frames))
                wf.close()
                
                # å°†æ–‡ä»¶åæ·»åŠ åˆ°å¤„ç†é˜Ÿåˆ—
                audio_queue.put(filename)
                print(f"æ–‡ä»¶å·²ä¿å­˜: {filename}")
    
    finally:
        # åœæ­¢å’Œå…³é—­æµ
        stream.stop_stream()
        stream.close()
        audio.terminate()
        print("å½•éŸ³çº¿ç¨‹å·²ç»“æŸ")

def remove_tail_repeats_auto(s: str) -> str:
    """
    è‡ªåŠ¨åˆ¤æ–­é‡å¤ç‰‡æ®µé•¿åº¦ï¼Œä»åå‘å‰åˆ é™¤è¿ç»­é‡å¤çš„å­—ç¬¦ä¸²æ®µï¼Œåªä¿ç•™ç¬¬ä¸€æ¬¡å‡ºç°ã€‚
    æ”¯æŒå¤šç§é•¿åº¦çš„é‡å¤é€’å½’å»é‡ã€‚
    """
    n = len(s)
    changed = True
    while changed:
        changed = False
        for seg_len in range(n // 2, 0, -1):
            # æ£€æŸ¥ç»“å°¾æ˜¯å¦æœ‰è¿ç»­é‡å¤
            last_seg = s[-seg_len:]
            count = 1
            for i in range(2, n // seg_len + 1):
                start = -i * seg_len
                end = -(i - 1) * seg_len if -(i - 1) * seg_len != 0 else None
                if s[start:end] == last_seg:
                    count += 1
                else:
                    break
            if count > 1:
                cutoff = len(s) - (count - 1) * seg_len
                s = s[:cutoff]
                n = len(s)
                changed = True
                break  # é‡æ–°ä»æœ€å¤§é•¿åº¦å¼€å§‹
    return s

def join_segments_text(segments):
    """
    æ¥æ”¶ä¸€ä¸ªåŒ…å«è‹¥å¹²å­—å…¸ï¼ˆæ¯ä¸ªå­—å…¸æ˜¯ä¸€ä¸ªsegmentï¼Œå«'text'å­—æ®µï¼‰çš„åˆ—è¡¨ï¼Œ
    è¿”å›æ‰€æœ‰textå­—æ®µæ‹¼æ¥çš„å­—ç¬¦ä¸²ï¼Œç”¨é€—å·åˆ†éš”ã€‚
    """
    texts = [segment['text'] for segment in segments]
    return 'ï¼Œ'.join(texts)  # ä½¿ç”¨ä¸­æ–‡é€—å·æ‹¼æ¥

def clean_mermaid_to_lr(text: str) -> str:
    """
    æ¸…ç† Mermaid å›¾å†…å®¹ï¼š
    - åˆ é™¤ ```mermaid å’Œ ```
    - å°† graph TD æ›¿æ¢ä¸º graph LR
    """
    lines = text.strip().splitlines()
    cleaned_lines = []
    inside_code_block = False

    for line in lines:
        stripped = line.strip()
        if stripped == "```mermaid":
            inside_code_block = True
            continue
        elif stripped == "```":
            inside_code_block = False
            continue
        elif inside_code_block:
            if stripped.startswith("graph TD"):
                cleaned_lines.append(stripped.replace("graph TD", "graph LR", 1))
            else:
                cleaned_lines.append(line)
    
    return "\n".join(cleaned_lines)

def process_audio(whisperModel):
    """å¤„ç†çº¿ç¨‹ï¼šå¤„ç†é˜Ÿåˆ—ä¸­çš„éŸ³é¢‘æ–‡ä»¶å¹¶åˆ é™¤"""
    print("å¤„ç†çº¿ç¨‹å·²å¯åŠ¨ï¼Œç­‰å¾…æ–‡ä»¶...")
    text = ""
    last_qwen_time = 0
    while True:
        if exitFlag:
            print("process_audioå¤„ç†çº¿ç¨‹é€€å‡º")
            break
        if not globalConfig.running:
            text = ""   
            # æ¸…ç©ºæ‰€æœ‰å¾…å¤„ç†å†…å®¹
            while not audio_queue.empty():
                try:
                    filename = audio_queue.get_nowait()
                    audio_queue.task_done()
                    os.remove(filename)
                    print(f"æ¸…ç†: {filename}")
                except queue.Empty:
                    break
            time.sleep(1)
            continue
        try:
            # ä»é˜Ÿåˆ—ä¸­è·å–æ–‡ä»¶å
            filename = audio_queue.get()
            
            # è¿™é‡Œæ·»åŠ ä½ çš„éŸ³é¢‘å¤„ç†ä»£ç 
            print(f"æ­£åœ¨å¤„ç†æ–‡ä»¶: {filename}")

            resWhisper = whisperModel.transcribe_audio(filename)
            resWhisperText = remove_tail_repeats_auto(join_segments_text(resWhisper["segments"]))
            if(resWhisperText == ''):
                print("å†…å®¹ä¸ºç©º")
                # æ ‡è®°ä»»åŠ¡å®Œæˆå¹¶åˆ é™¤æ–‡ä»¶
                audio_queue.task_done()
                os.remove(filename)
                print(f"æ–‡ä»¶å·²åˆ é™¤: {filename}")
                continue
            text += resWhisperText
            #textå†™å…¥æ–‡æœ¬
            with open('out.txt', "w") as f:
                f.write(text)
            print(text)
            # Qwenç”Ÿæˆé—´éš”æ§åˆ¶
            now = time.time()
            if now - last_qwen_time >= globalConfig.qwen_interval:
                print(f"æ–‡æœ¬é•¿åº¦: {len(text)}")
                
                # ä½¿ç”¨ç®€åŒ–çš„ä»»åŠ¡å‡½æ•°
                try:
                    res = generate_mermaid(text, len(text)*3)
                    last_qwen_time = now
                    
                    if res:
                        # æŠŠresçš„å†…å®¹å†™å…¥æ–‡ä»¶
                        os.makedirs('/data/mermaidRender/text', exist_ok=True)
                        with open('/data/mermaidRender/dist/text/outmermaid.mmd', "w") as f:
                            f.write(clean_mermaid_to_lr(res))
                        print("æ€ç»´å¯¼å›¾å·²æ›´æ–°")
                    else:
                        print("æ€ç»´å¯¼å›¾ç”Ÿæˆå¤±è´¥")
                        
                except Exception as e:
                    print(f"Qwen å¤„ç†å¤±è´¥: {e}")
                
            print(f"æ–‡ä»¶å¤„ç†å®Œæˆ: {filename}")
            print(f"å¤„ç†ç»“æœ: {text}")

            # æ ‡è®°ä»»åŠ¡å®Œæˆ
            audio_queue.task_done()
            os.remove(filename)
            print(f"æ–‡ä»¶å·²åˆ é™¤: {filename}")
        except queue.Empty:
            # é˜Ÿåˆ—ä¸ºç©ºï¼Œç­‰å¾…globalConfig.runningä¸ºTrueå†ç»§ç»­
            time.sleep(1)
            continue
        except Exception as e:
            print(f"å¤„ç†éŸ³é¢‘æ—¶å‡ºé”™: {e}")
            # ç¡®ä¿ä»»åŠ¡è¢«æ ‡è®°ä¸ºå®Œæˆï¼Œå³ä½¿å‡ºé”™
            try:
                audio_queue.task_done()
                if 'filename' in locals() and os.path.exists(filename):
                    os.remove(filename)
            except:
                pass

def initModel():
    """åˆå§‹åŒ–æ¨¡å‹"""
    print("=== åˆå§‹åŒ–æ¨¡å‹ ===")
    
    # é¦–å…ˆæ£€æŸ¥å…±äº«ç®¡ç†å™¨çŠ¶æ€
    status = simple_qwen.get_status()
    print(f"å…±äº«ç®¡ç†å™¨åˆå§‹çŠ¶æ€: {status}")
    
    # åˆå§‹åŒ– Qwen æ¨¡å‹ï¼ˆå¦‚æœå°šæœªåŠ è½½ï¼‰
    if not simple_qwen.is_loaded():
        print("ğŸ”„ åˆå§‹åŒ– Qwen æ¨¡å‹...")
        initMermaid("åŠ è½½Qwenæ¨¡å‹...")
        
        class Args:
            model_path = "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel"
            config_path = "/data/LLM-TPU/models/Qwen3/python_demo/config"
            devid = "0"
            temperature = 0.5
            top_p = 1.0
            repeat_penalty = 1.8
            repeat_last_n = 32
            max_new_tokens = 1024
            generation_mode = "greedy"
            prompt_mode = "prompted"
            enable_history = False

        args = Args()
        
        try:
            simple_qwen.initialize_model(args)
            print("âœ… Qwen æ¨¡å‹åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            print(f"âŒ Qwen æ¨¡å‹åˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    else:
        print("âœ… Qwen æ¨¡å‹å·²ç»åŠ è½½")
    
    # åˆå§‹åŒ– Whisper æ¨¡å‹
    print("ğŸ”„ åˆå§‹åŒ– Whisper æ¨¡å‹...")
    initMermaid("åŠ è½½Whisperæ¨¡å‹...")
    
    try:
        from transcribef import TranscribeWorker
        worker = TranscribeWorker()
        print("âœ… Whisper æ¨¡å‹åˆå§‹åŒ–å®Œæˆ")
    except Exception as e:
        print(f"âŒ Whisper æ¨¡å‹åˆå§‹åŒ–å¤±è´¥: {e}")
        raise
    
    initMermaid("")
    
    # éªŒè¯æœ€ç»ˆçŠ¶æ€
    final_status = simple_qwen.get_status()
    print(f"æ¨¡å‹åˆå§‹åŒ–å®ŒæˆåçŠ¶æ€: {final_status}")
    
    return worker

if __name__ == "__main__":
    try:
        print("ğŸš€ å¯åŠ¨è¯­éŸ³è¯†åˆ«æ€ç»´å¯¼å›¾ç³»ç»Ÿ...")
        
        # åˆå§‹åŒ–ç¯å¢ƒ
        initEnv()
        
        # åˆå§‹åŒ–æ¨¡å‹
        worker = initModel()
        
        # å¯åŠ¨APIæœåŠ¡å™¨ï¼ˆåœ¨å•ç‹¬çº¿ç¨‹ä¸­ï¼‰
        api_thread = threading.Thread(target=start_api_server, daemon=True)
        api_thread.start()
        
        # åˆ›å»ºå¹¶å¯åŠ¨å½•éŸ³çº¿ç¨‹
        record_thread = threading.Thread(target=record_audio)
        record_thread.start()
        
        # åˆ›å»ºå¹¶å¯åŠ¨å¤„ç†çº¿ç¨‹ - æ³¨æ„è¿™é‡Œåªä¼ å…¥ worker
        process_thread = threading.Thread(target=process_audio, args=(worker,))
        process_thread.start()

        # åˆ›å»ºå¹¶å¯åŠ¨é…ç½®ç›‘æ§çº¿ç¨‹
        config_thread = threading.Thread(target=globalConfig.config_watcher, daemon=True)
        config_thread.start()
        
        print("ç³»ç»Ÿå¯åŠ¨å®Œæˆï¼æŒ‰ Ctrl+C é€€å‡º...")
        print("=" * 50)
        
        # ä¸»çº¿ç¨‹ç­‰å¾…ç”¨æˆ·ä¸­æ–­
        while True:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\næ­£åœ¨åœæ­¢æ‰€æœ‰çº¿ç¨‹...")
        exitFlag = True
        
        # ç­‰å¾…çº¿ç¨‹ç»“æŸ
        print("ç­‰å¾…å½•éŸ³çº¿ç¨‹ç»“æŸ...")
        record_thread.join(timeout=3)
        
        print("ç­‰å¾…å¤„ç†çº¿ç¨‹ç»“æŸ...")
        process_thread.join(timeout=3)
        
        # æ¸…ç†å‰©ä½™æ–‡ä»¶
        print("æ¸…ç†å‰©ä½™æ–‡ä»¶...")
        while not audio_queue.empty():
            try:
                filename = audio_queue.get_nowait()
                audio_queue.task_done()
                if os.path.exists(filename):
                    os.remove(filename)
                print(f"æ¸…ç†: {filename}")
            except queue.Empty:
                break
            except Exception as e:
                print(f"æ¸…ç†æ–‡ä»¶æ—¶å‡ºé”™: {e}")
        
        # å…³é—­å…±äº«ç®¡ç†å™¨
        simple_qwen.shutdown()
        
        print("æ‰€æœ‰çº¿ç¨‹å·²åœæ­¢ï¼Œç¨‹åºé€€å‡º")
        
    except Exception as e:
        print(f"ç¨‹åºè¿è¡Œå‡ºé”™: {e}")
        import traceback
        traceback.print_exc()
        
        # ç¡®ä¿æ¸…ç†
        exitFlag = True
        simple_qwen.shutdown()
'''
'''lightrag_bmodel2.py
# å¯¼å…¥æ“ä½œç³»ç»Ÿæ¨¡å—ï¼Œç”¨äºæ–‡ä»¶è·¯å¾„å’Œç¯å¢ƒå˜é‡æ“ä½œ
import os
# ç¦ç”¨ tiktoken ç¼“å­˜ç›®å½•ï¼Œé¿å…ç½‘ç»œè¯·æ±‚

os.environ['TOKENIZERS_PARALLELISM'] = 'false'
os.environ['PYTHONUNBUFFERED'] = '1'

import sys
import hashlib
from watchdog.observers.polling import PollingObserver as Observer
from watchdog.events import FileSystemEventHandler

# æ·»åŠ é€‚é…å™¨æ¨¡å—è·¯å¾„
sys.path.append('/data/qwen_embedding')
# æ·»åŠ  Qwen LLM é€‚é…å™¨è·¯å¾„
sys.path.append('/data/whisper-TPU_py/bmwhisper')

# å¯¼å…¥å¼‚æ­¥ç¼–ç¨‹æ¨¡å—
import asyncio
# å¯¼å…¥æ£€æŸ¥æ¨¡å—ï¼Œç”¨äºæ£€æŸ¥å¯¹è±¡ç±»å‹
import inspect
# å¯¼å…¥æ—¥å¿—è®°å½•æ¨¡å—
import logging
# å¯¼å…¥æ—¥å¿—é…ç½®æ¨¡å—
import logging.config
# å¯¼å…¥LightRAGæ ¸å¿ƒç»„ä»¶ï¼šä¸»ç±»å’ŒæŸ¥è¯¢å‚æ•°ç±»
from lightrag import LightRAG, QueryParam
# å¯¼å…¥OpenAIå…¼å®¹çš„å®Œæˆå‡½æ•°
from lightrag.llm.openai import openai_complete_if_cache
# å¯¼å…¥å·¥å…·å‡½æ•°ï¼šåµŒå…¥å‡½æ•°ç±»ã€æ—¥å¿—å™¨ã€è¯¦ç»†è°ƒè¯•è®¾ç½®
from lightrag.utils import EmbeddingFunc, logger, set_verbose_debug
# å¯¼å…¥å…±äº«å­˜å‚¨çš„ç®¡é“çŠ¶æ€åˆå§‹åŒ–å‡½æ•°
from lightrag.kg.shared_storage import initialize_pipeline_status
# å¯¼å…¥PyTorchæ·±åº¦å­¦ä¹ æ¡†æ¶
import torch
import numpy as np
import time

# å¯¼å…¥æˆ‘ä»¬çš„ LightRAG Qwen é€‚é…å™¨ï¼ˆç”¨äºembeddingï¼‰
from lightrag_qwen_adapter import get_lightrag_embedding_func

# å¯¼å…¥ Qwen LLM é€‚é…å™¨ï¼ˆç”¨äº LLMï¼Œé€šè¿‡ HTTP APIï¼‰
from qwen_llm_adapter import qwen_llm_model_func, MODEL_CONFIG

# å¯¼å…¥ç®€åŒ–çš„å…±äº«ç®¡ç†å™¨ç”¨äºçŠ¶æ€æ£€æŸ¥
from shared_qwen_manager import simple_qwen

# ä¿®æ”¹æ¨¡å‹è·¯å¾„
MODEL_CONFIG["llm_model_path"] = "/data/qwen4btune_w4bf16_seq8192_bm1684x_1dev_20250721_195513.bmodel"
MODEL_CONFIG["config_path"] = "/data/LLM-TPU/models/Qwen3/python_demo/config"
MODEL_CONFIG["temperature"] = 0.5

# å®šä¹‰å·¥ä½œç›®å½•è·¯å¾„
WORKING_DIR = "./result/biography_final"
# åœ¨ WORKING_DIR å®šä¹‰åæ·»åŠ è¾“å‡ºç›®å½•é…ç½®
OUTPUT_DIR = "/data/mermaidRender/dist"

# ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
if not os.path.exists(OUTPUT_DIR):
    print(f"Creating output directory: {OUTPUT_DIR}")
    os.makedirs(OUTPUT_DIR)
else:
    print(f"Output directory already exists: {OUTPUT_DIR},continue...")
    
# å¦‚æœå·¥ä½œç›®å½•ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥ç›®å½•
if not os.path.exists(WORKING_DIR):
    print(f"Setting directory not exist,creating working directory: {WORKING_DIR}")
    os.mkdir(WORKING_DIR)
else:
    print(f"Working directory already exists: {WORKING_DIR},continue...")

# æ–‡ä»¶ç›‘æ§å¤„ç†å™¨ç±» - ä¿®æ”¹ç‰ˆæœ¬
class QuestionFileHandler(FileSystemEventHandler):
    """é—®é¢˜æ–‡ä»¶å˜åŒ–ç›‘æ§å¤„ç†å™¨"""
    def __init__(self, callback, loop):
        self.callback = callback
        self.last_content_hash = None
        self.loop = loop  # ä¿å­˜äº‹ä»¶å¾ªç¯å¼•ç”¨
        
    def on_modified(self, event):
        if not event.is_directory and event.src_path.endswith('ragQuestions.txt'):
            # æ£€æŸ¥æ–‡ä»¶å†…å®¹æ˜¯å¦çœŸçš„æ”¹å˜äº†
            try:
                with open(event.src_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                content_hash = hashlib.md5(content.encode()).hexdigest()
                
                if content_hash != self.last_content_hash:
                    self.last_content_hash = content_hash
                    # ä½¿ç”¨ run_coroutine_threadsafe å®‰å…¨åœ°åœ¨äº‹ä»¶å¾ªç¯ä¸­è°ƒåº¦åç¨‹
                    asyncio.run_coroutine_threadsafe(
                        self.callback(event.src_path), 
                        self.loop
                    )
            except Exception as e:
                print(f"è¯»å–æ–‡ä»¶æ—¶å‡ºé”™: {e}")

# å®šä¹‰æ—¥å¿—é…ç½®å‡½æ•°
def configure_logging():
    """é…ç½®åº”ç”¨ç¨‹åºçš„æ—¥å¿—è®°å½•"""
    # é‡ç½®ç°æœ‰çš„å¤„ç†ç¨‹åºä»¥ç¡®ä¿å¹²å‡€çš„é…ç½®
    for logger_name in ["uvicorn", "uvicorn.access", "uvicorn.error", "lightrag"]:
        logger_instance = logging.getLogger(logger_name)
        logger_instance.handlers = []
        logger_instance.filters = []

    # ä»ç¯å¢ƒå˜é‡è·å–æ—¥å¿—ç›®å½•è·¯å¾„ï¼Œé»˜è®¤ä½¿ç”¨å½“å‰ç›®å½•
    log_dir = os.getenv("LOG_DIR", os.getcwd())
    # æ„å»ºæ—¥å¿—æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
    log_file_path = os.path.abspath(
        os.path.join(log_dir, "lightrag_qwen_bmodel_demo.log")
    )

    print(f"\nLightRAG Qwen embedding bmodel demo log file: {log_file_path}\n")
    os.makedirs(os.path.dirname(log_dir), exist_ok=True)

    # ä»ç¯å¢ƒå˜é‡è·å–æ—¥å¿—æ–‡ä»¶æœ€å¤§å¤§å°å’Œå¤‡ä»½æ•°é‡
    log_max_bytes = int(os.getenv("LOG_MAX_BYTES", 10485760))  # é»˜è®¤10MB
    log_backup_count = int(os.getenv("LOG_BACKUP_COUNT", 5))  # é»˜è®¤5ä¸ªå¤‡ä»½

    # é…ç½®æ—¥å¿—ç³»ç»Ÿ
    logging.config.dictConfig(
        {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "format": "%(levelname)s: %(message)s",
                },
                "detailed": {
                    "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                },
            },
            "handlers": {
                "console": {
                    "formatter": "default",
                    "class": "logging.StreamHandler",
                    "stream": "ext://sys.stderr",
                },
                "file": {
                    "formatter": "detailed",
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": log_file_path,
                    "maxBytes": log_max_bytes,
                    "backupCount": log_backup_count,
                    "encoding": "utf-8",
                },
            },
            "loggers": {
                "lightrag": {
                    "handlers": ["console", "file"],
                    "level": "INFO",
                    "propagate": False,
                },
            },
        }
    )

    logger.setLevel(logging.INFO)
    set_verbose_debug(os.getenv("VERBOSE_DEBUG", "false").lower() == "true")

# å®šä¹‰æµå¼è¾“å‡ºæ‰“å°å‡½æ•°
async def print_stream(stream):
    async for chunk in stream:
        if chunk:
            print(chunk, end="", flush=True)

# æ£€æŸ¥æ¨¡å‹çŠ¶æ€çš„å‡½æ•°
def check_model_availability():
    """æ£€æŸ¥æ¨¡å‹æ˜¯å¦å¯ç”¨"""
    try:
        status = simple_qwen.get_status()
        print(f"æ¨¡å‹çŠ¶æ€æ£€æŸ¥: {status}")
        
        if status["local_model"] or status["external_model"]:
            print("âœ… æ£€æµ‹åˆ°å¯ç”¨çš„ LLM æ¨¡å‹")
            return True
        else:
            print("âš ï¸ æœªæ£€æµ‹åˆ°å¯ç”¨çš„ LLM æ¨¡å‹")
            return False
    except Exception as e:
        print(f"âŒ æ¨¡å‹çŠ¶æ€æ£€æŸ¥å¤±è´¥: {e}")
        return False

# æ£€æŸ¥ API æœåŠ¡å™¨çŠ¶æ€
def check_api_server_status():
    """æ£€æŸ¥APIæœåŠ¡å™¨çŠ¶æ€"""
    try:
        import requests
        response = requests.get("http://localhost:8899/status", timeout=5)
        if response.status_code == 200:
            status = response.json()
            print(f"âœ… APIæœåŠ¡å™¨å¯ç”¨: {status}")
            return True
        else:
            print(f"âš ï¸ APIæœåŠ¡å™¨å“åº”å¼‚å¸¸: {response.status_code}")
            return False
    except Exception as e:
        print(f"âŒ APIæœåŠ¡å™¨ä¸å¯ç”¨: {e}")
        return False

async def initialize_rag():
    """ä½¿ç”¨ Qwen embedding bmodel + HTTP LLM API åˆå§‹åŒ– RAG ç³»ç»Ÿ"""
    
    print("æ­£åœ¨åˆå§‹åŒ– LightRAG with Qwen embedding bmodel + HTTP LLM API...")
    
    # 1. æ£€æŸ¥ LLM æ¨¡å‹çŠ¶æ€
    print("\n=== æ£€æŸ¥ LLM æ¨¡å‹çŠ¶æ€ ===")
    llm_available = check_model_availability()
    api_available = check_api_server_status()
    
    if not (llm_available or api_available):
        print("âš ï¸ è­¦å‘Šï¼šLLM æ¨¡å‹å’ŒAPIæœåŠ¡å™¨éƒ½ä¸å¯ç”¨")
        print("è¯·ç¡®ä¿ sample_audio.py æ­£åœ¨è¿è¡Œ")
        print("ç»§ç»­åˆå§‹åŒ–ï¼Œä½†LLMåŠŸèƒ½å¯èƒ½å—é™...")
    else:
        print("âœ… LLM æ¨¡å‹é€šè¿‡ HTTP API å¯ç”¨")
    
    # 2. åˆå§‹åŒ– Embedding æ¨¡å‹ï¼ˆæœ¬åœ°åŠ è½½ï¼‰
    print("\n=== åˆå§‹åŒ– Embedding æ¨¡å‹ ===")
    try:
        qwen_embedding_func = get_lightrag_embedding_func(
            model_path='/data/Qwen3_Embedding_0.6B_my_1684x_128_f16.bmodel',
            tokenizer_path=None,
            batch_size=1,
            device="tpu",
            async_mode=True
        )
        print("âœ… Embedding æ¨¡å‹åˆå§‹åŒ–æˆåŠŸï¼ˆæœ¬åœ°bmodelï¼‰")
    except Exception as e:
        print(f"âŒ Embedding æ¨¡å‹åˆå§‹åŒ–å¤±è´¥: {e}")
        raise
    
    # 3. åˆ›å»º LightRAG å®ä¾‹
    print("\n=== åˆ›å»º LightRAG å®ä¾‹ ===")
    try:
        # åˆ›å»ºè‡ªå®šä¹‰ tokenizer æ¥æ›¿ä»£ tiktoken
        class SimpleChineseTokenizer:
            """ç®€å•çš„ä¸­æ–‡åˆ†è¯å™¨ï¼Œé¿å…ä½¿ç”¨ tiktoken"""
            
            def encode(self, text: str) -> list[int]:
                """å°†æ–‡æœ¬ç¼–ç ä¸º token ID åˆ—è¡¨"""
                # å­—ç¬¦çº§ç¼–ç ï¼Œé€‚åˆä¸­æ–‡
                return [ord(c) for c in text if ord(c) <= 65535]  # è¿‡æ»¤è¶…å‡ºBMPçš„å­—ç¬¦
            
            def decode(self, tokens: list[int]) -> str:
                """å°† token ID åˆ—è¡¨è§£ç ä¸ºæ–‡æœ¬"""
                try:
                    return ''.join([chr(t) for t in tokens if 0 <= t <= 65535])
                except ValueError:
                    return ""
        
        # åˆ›å»º tokenizer å®ä¾‹
        from lightrag.utils import Tokenizer
        custom_tokenizer = Tokenizer(
            model_name="chinese_custom", 
            tokenizer=SimpleChineseTokenizer()
        )
        
        print("âœ… è‡ªå®šä¹‰ tokenizer åˆ›å»ºæˆåŠŸï¼ˆæ— éœ€ tiktokenï¼‰")
        
        # åˆ›å»ºLightRAGå®ä¾‹ï¼Œä½¿ç”¨HTTP APIçš„LLM + æœ¬åœ°embedding + è‡ªå®šä¹‰tokenizer
        rag = LightRAG(
            working_dir=WORKING_DIR,
            llm_model_func=qwen_llm_model_func,  # ä½¿ç”¨HTTP API
            embedding_func=EmbeddingFunc(
                embedding_dim=1024,
                max_token_size=5000,
                func=qwen_embedding_func,  # ä½¿ç”¨æœ¬åœ°bmodel
            ),
            tokenizer=custom_tokenizer,  # å…³é”®ï¼šä½¿ç”¨è‡ªå®šä¹‰tokenizer
            tiktoken_model_name=None,     # ç¡®ä¿ä¸ä½¿ç”¨tiktoken
        )
        print("âœ… LightRAG å®ä¾‹åˆ›å»ºæˆåŠŸ")
        
    except Exception as e:
        print(f"âŒ LightRAG åˆå§‹åŒ–å¤±è´¥: {e}")
        print("å°è¯•ä½¿ç”¨æœ€å°é…ç½®é‡æ–°åˆå§‹åŒ–...")
        
        # å¤‡ç”¨æ–¹æ¡ˆï¼šæ›´ç®€å•çš„tokenizer
        class BasicTokenizer:
            def encode(self, text: str) -> list[int]:
                # æœ€ç®€å•çš„å­—èŠ‚ç¼–ç 
                return list(text.encode('utf-8'))
            
            def decode(self, tokens: list[int]) -> str:
                try:
                    return bytes(tokens).decode('utf-8', errors='ignore')
                except:
                    return ""
        
        from lightrag.utils import Tokenizer
        basic_tokenizer = Tokenizer(
            model_name="basic", 
            tokenizer=BasicTokenizer()
        )
        
        rag = LightRAG(
            working_dir=WORKING_DIR,
            llm_model_func=qwen_llm_model_func,
            embedding_func=EmbeddingFunc(
                embedding_dim=1024,
                max_token_size=5000,
                func=qwen_embedding_func,
            ),
            tokenizer=basic_tokenizer,    # ä½¿ç”¨åŸºç¡€tokenizer
            tiktoken_model_name=None,
        )

    # 4. åˆå§‹åŒ–å­˜å‚¨ç³»ç»Ÿ
    print("\n=== åˆå§‹åŒ–å­˜å‚¨ç³»ç»Ÿ ===")
    try:
        await rag.initialize_storages()
        await initialize_pipeline_status()
        print("âœ… å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å‡ºç°é—®é¢˜: {e}")
        print("ç»§ç»­è¿è¡Œ...")

    print("âœ… LightRAG åˆå§‹åŒ–å®Œæˆï¼ˆEmbeddingæœ¬åœ° + LLMè¿œç¨‹APIï¼‰")
    return rag

# é—®é¢˜æ–‡ä»¶è§£æå‡½æ•°
def parse_question_file(file_path: str) -> tuple:
    """è§£æé—®é¢˜æ–‡ä»¶ï¼Œè¿”å› (åºå·, é—®é¢˜å†…å®¹)"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        
        if len(lines) >= 2:
            sequence_num = lines[0]
            question = lines[1]
            return sequence_num, question
        elif len(lines) == 1:
            # åªæœ‰ä¸€è¡Œï¼Œå½“ä½œé—®é¢˜å¤„ç†
            return "1", lines[0]
        else:
            return None, None
            
    except FileNotFoundError:
        print(f"é—®é¢˜æ–‡ä»¶ {file_path} ä¸å­˜åœ¨")
        return None, None
    except Exception as e:
        print(f"è§£æé—®é¢˜æ–‡ä»¶æ—¶å‡ºé”™: {e}")
        return None, None

# æ–‡æ¡£æ¥å£å‡½æ•°
def read_questions_from_file(file_path: str) -> list:
    """ä»æ–‡ä»¶ä¸­è¯»å–é—®é¢˜åˆ—è¡¨"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            questions = [line.strip() for line in f if line.strip()]
        return questions
    except FileNotFoundError:
        print(f"Warning: {file_path} not found, using default question")
        return ["ä»‹ç»ç™½è¡€ç—…ä¸ç™½ç»†èƒçš„å…³ç³»"]  # é»˜è®¤é—®é¢˜

def save_chunk_ids(chunk_ids: list, file_path: str):
    """å°†chunk IDä¿å­˜åˆ°æ–‡ä»¶"""
    with open(file_path, 'w', encoding='utf-8') as f:
        for chunk_id in chunk_ids:
            f.write(f"{chunk_id}\n")
    print(f"Chunk IDs saved to: {file_path}")

def save_response(response: str, file_path: str):
    """å°†å“åº”ä¿å­˜åˆ°æ–‡ä»¶"""
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(response)
    print(f"Response saved to: {file_path}")

async def collect_stream_response(stream):
    """æ”¶é›†æµå¼å“åº”ä¸ºå®Œæ•´å­—ç¬¦ä¸²"""
    response_parts = []
    async for chunk in stream:
        if chunk:
            print(chunk, end="", flush=True)  # ä¿æŒæ§åˆ¶å°è¾“å‡º
            response_parts.append(chunk)
    return ''.join(response_parts)

# å¤„ç†å•ä¸ªé—®é¢˜çš„å‡½æ•°
async def process_single_question(rag, question: str, sequence_num: str):
    """å¤„ç†å•ä¸ªé—®é¢˜çš„å®Œæ•´æµç¨‹"""
    print(f"\n{'='*60}")
    print(f"å¤„ç†é—®é¢˜åºå· {sequence_num}: {question}")
    print('='*60)
    
    try:
        # 1. ç›´æ¥è°ƒç”¨ chunks_vdb.query æ¥è·å–æ£€ç´¢ç»“æœ
        print("\n=====================")
        print("Direct chunk search")
        print("=====================")
        start_time = time.time()
        
        try:
            chunks_result = await rag.chunks_vdb.query(
                query=question,
                top_k=5,
                ids=None
            )
            
            # æå– chunk IDs
            chunk_ids = [chunk.get('id', 'N/A') for chunk in chunks_result]
            
            # æ‰“å°æŸ¥è¯¢ç»“æœ
            print(f"æ£€ç´¢åˆ° {len(chunks_result)} ä¸ªç›¸å…³ chunks:")
            for i, chunk in enumerate(chunks_result):
                print(f"\nChunk {i+1}:")
                print(f"  ID: {chunk.get('id', 'N/A')}")
                print(f"  Score: {chunk.get('distance', 'N/A')}")
                print(f"  Content: {chunk.get('content', '')[:100]}...")
                print(f"  Full Doc ID: {chunk.get('full_doc_id', 'N/A')}")
                print(f"  Chunk Order Index: {chunk.get('chunk_order_index', 'N/A')}")
                print(f"  File Path: {chunk.get('file_path', 'N/A')}")

            # 2. ä¿å­˜ chunk IDs åˆ° ragSearch.txt
            chunk_ids_file = os.path.join(OUTPUT_DIR, "ragSearch.txt")
            save_chunk_ids(chunk_ids, chunk_ids_file)
            
        except Exception as e:
            print(f"âš ï¸ Chunk æ£€ç´¢å¤±è´¥: {e}")
            chunk_ids_file = os.path.join(OUTPUT_DIR, "ragSearch.txt")
            save_chunk_ids(["æ£€ç´¢å¤±è´¥"], chunk_ids_file)
        
        # 3. æ‰§è¡Œå®Œæ•´çš„RAGæŸ¥è¯¢
        print(f"\n=====================")
        print("Query mode: naive - Full RAG Search")
        print("=====================")
        start_time = time.time()
        
        try:
            resp = await rag.aquery(
                question,
                param=QueryParam(mode="naive", stream=True),
            )
            end_time = time.time()
            print(f"Search execution time: {end_time - start_time:.2f} seconds")
            
            # 4. å¤„ç†å“åº”å¹¶ä¿å­˜åˆ° RAGResult.txt
            if inspect.isasyncgen(resp):
                # æµå¼å“åº”
                print("Response:")
                response_text = await collect_stream_response(resp)
            else:
                # éæµå¼å“åº”
                response_text = str(resp)
                print(f"Response: {response_text}")
            
            # ä¿å­˜å“åº”
            response_file = os.path.join(OUTPUT_DIR, "RAGResult.txt")
            save_response(response_text, response_file)
            
            print(f"\né—®é¢˜åºå· {sequence_num} å¤„ç†å®Œæˆ")
            print(f"- Chunk IDs ä¿å­˜è‡³: {chunk_ids_file}")
            print(f"- å“åº”ä¿å­˜è‡³: {response_file}")
            
            return True
            
        except Exception as e:
            print(f"âš ï¸ RAG æŸ¥è¯¢å¤±è´¥: {e}")
            # å°è¯•ç›´æ¥ä½¿ç”¨ LLM
            print("å°è¯•ç›´æ¥ä½¿ç”¨ LLM å›ç­”...")
            try:
                response_text = await qwen_llm_model_func(
                    question,
                    system_prompt="ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„åŠ©æ‰‹ï¼Œè¯·æ ¹æ®é—®é¢˜æä¾›å‡†ç¡®çš„å›ç­”ã€‚"
                )
                
                response_file = os.path.join(OUTPUT_DIR, "RAGResult.txt")
                save_response(f"[ç›´æ¥LLMå›ç­”]\n{response_text}", response_file)
                
                print(f"âœ… ä½¿ç”¨ç›´æ¥LLMæ¨¡å¼å®Œæˆå›ç­”")
                return True
                
            except Exception as llm_e:
                print(f"âŒ ç›´æ¥LLMå›ç­”ä¹Ÿå¤±è´¥: {llm_e}")
                
                # ä¿å­˜é”™è¯¯ä¿¡æ¯
                error_msg = f"RAGæŸ¥è¯¢å¤±è´¥: {e}\nLLMæŸ¥è¯¢å¤±è´¥: {llm_e}"
                response_file = os.path.join(OUTPUT_DIR, "RAGResult.txt")
                save_response(f"[é”™è¯¯]\n{error_msg}", response_file)
                
                return False
        
    except Exception as e:
        print(f"å¤„ç†é—®é¢˜æ—¶å‡ºé”™: {e}")
        import traceback
        traceback.print_exc()
        
        # ä¿å­˜é”™è¯¯ä¿¡æ¯
        error_msg = f"å¤„ç†å¤±è´¥: {e}"
        response_file = os.path.join(OUTPUT_DIR, "RAGResult.txt")
        save_response(f"[é”™è¯¯]\n{error_msg}", response_file)
        
        return False

# ç›‘æ§å’Œå¤„ç†é—®é¢˜çš„ä¸»å‡½æ•° - ä¿®æ”¹ç‰ˆæœ¬
async def monitor_and_process_questions(rag):
    """ç›‘æ§é—®é¢˜æ–‡ä»¶å¹¶å¤„ç†"""
    questions_file = os.path.join(OUTPUT_DIR, "ragQuestions.txt")
    processed_sequences = set()  # è®°å½•å·²å¤„ç†çš„åºå·
    
    async def handle_file_change(file_path):
        """å¤„ç†æ–‡ä»¶å˜åŒ–"""
        try:
            # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºç©º
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            if not content:
                print("é—®é¢˜æ–‡ä»¶ä¸ºç©ºï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥é—®é¢˜...")
                return
            
            sequence_num, question = parse_question_file(file_path)
            
            if sequence_num and question:
                # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°é—®é¢˜ï¼ˆåŸºäºåºå·ï¼‰
                if sequence_num not in processed_sequences:
                    print(f"\næ£€æµ‹åˆ°æ–°é—®é¢˜: åºå· {sequence_num}")
                    success = await process_single_question(rag, question, sequence_num)
                    
                    if success:
                        processed_sequences.add(sequence_num)
                        print(f"é—®é¢˜åºå· {sequence_num} å¤„ç†æˆåŠŸ")
                    else:
                        print(f"é—®é¢˜åºå· {sequence_num} å¤„ç†å¤±è´¥")
                else:
                    print(f"é—®é¢˜åºå· {sequence_num} å·²å¤„ç†è¿‡ï¼Œè·³è¿‡")
            else:
                print("é—®é¢˜æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–ä¸ºç©º")
        except Exception as e:
            print(f"å¤„ç†æ–‡ä»¶å˜åŒ–æ—¶å‡ºé”™: {e}")
            import traceback
            traceback.print_exc()
    
    # è·å–å½“å‰äº‹ä»¶å¾ªç¯
    loop = asyncio.get_running_loop()
    
    # åˆ›å»ºæ–‡ä»¶ç›‘æ§å¤„ç†å™¨ï¼Œä¼ å…¥äº‹ä»¶å¾ªç¯
    event_handler = QuestionFileHandler(callback=handle_file_change, loop=loop)
    
    # è®¾ç½®æ–‡ä»¶ç›‘æ§
    observer = Observer()
    observer.schedule(event_handler, OUTPUT_DIR, recursive=False)
    observer.start()
    
    print(f"å¼€å§‹ç›‘æ§é—®é¢˜æ–‡ä»¶: {questions_file}")
    print("è¯·åœ¨ ragQuestions.txt ä¸­å†™å…¥é—®é¢˜ï¼Œæ ¼å¼å¦‚ä¸‹:")
    print("ç¬¬ä¸€è¡Œ: åºå·")
    print("ç¬¬äºŒè¡Œ: é—®é¢˜å†…å®¹")
    print("æŒ‰ Ctrl+C é€€å‡ºç›‘æ§")
    
    # åˆå§‹åŒ–æ—¶è¯»å–å½“å‰åºå·ï¼Œä½†ä¸å¤„ç†
    if os.path.exists(questions_file):
        try:
            sequence_num, _ = parse_question_file(questions_file)
            if sequence_num:
                processed_sequences.add(sequence_num)
                print(f"æ£€æµ‹åˆ°ç°æœ‰é—®é¢˜æ–‡ä»¶ï¼Œå½“å‰åºå·: {sequence_num}ï¼Œç­‰å¾…åºå·å˜åŒ–...")
        except:
            pass
    
    try:
        # ä¿æŒç›‘æ§è¿è¡Œ
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        print("\nåœæ­¢æ–‡ä»¶ç›‘æ§")
        observer.stop()
    
    observer.join()

def create_example_question_file():
    """åˆ›å»ºç©ºçš„é—®é¢˜æ–‡ä»¶"""
    questions_file = os.path.join(OUTPUT_DIR, "ragQuestions.txt")
    if not os.path.exists(questions_file):
        # åˆ›å»ºç©ºæ–‡ä»¶ï¼Œä¸å†™å…¥ä»»ä½•å†…å®¹
        with open(questions_file, 'w', encoding='utf-8') as f:
            f.write("")
        
        print(f"åˆ›å»ºç©ºçš„é—®é¢˜æ–‡ä»¶: {questions_file}")
        print("ç­‰å¾…ç”¨æˆ·è¾“å…¥é—®é¢˜...")
    else:
        print(f"é—®é¢˜æ–‡ä»¶å·²å­˜åœ¨: {questions_file}")
        print("ç­‰å¾…é—®é¢˜åºå·å˜åŒ–...")

# å®šä¹‰å¼‚æ­¥ä¸»å‡½æ•°
async def main():
    try:
        # é¦–å…ˆæ£€æŸ¥æ¨¡å‹çŠ¶æ€
        print("=" * 60)
        print("æ£€æŸ¥ç³»ç»ŸçŠ¶æ€...")
        print("=" * 60)
        
        llm_available = check_model_availability()
        api_available = check_api_server_status()
        
        if not (llm_available or api_available):
            print("âš ï¸ è­¦å‘Šï¼šLLMæ¨¡å‹å¯èƒ½æœªå‡†å¤‡å°±ç»ª")
            print("è¯·ç¡®ä¿ sample_audio.py æ­£åœ¨è¿è¡Œ")
            print("ç»§ç»­åˆå§‹åŒ–ï¼Œå°†å°è¯•é€šè¿‡APIè®¿é—®...")
        
        # åˆå§‹åŒ–RAGå®ä¾‹
        print("\n" + "=" * 60)
        print("åˆå§‹åŒ– RAG ç³»ç»Ÿ...")
        print("=" * 60)
        
        rag = await initialize_rag()

        # æµ‹è¯•åµŒå…¥å‡½æ•°
        test_text = ["This is a test string for embedding with Qwen embedding bmodel."]
        print("\n=======================")
        print("Testing Qwen embedding bmodel embedding function")
        print("========================")
        print(f"Test text: {test_text}")
        
        try:
            embedding = await rag.embedding_func(test_text)
            embedding_dim = embedding.shape[1]
            print(f"âœ… Detected embedding dimension: {embedding_dim}")
            print(f"Embedding shape: {embedding.shape}")
            print(f"First 10 values: {embedding[0][:10]}\n")
        except Exception as e:
            print(f"âš ï¸ Embedding æµ‹è¯•å¤±è´¥: {e}")

        # æµ‹è¯•LLMå‡½æ•°
        print("\n=======================")
        print("Testing Qwen LLM HTTP API function")
        print("========================")
        test_prompt = "ä½ å¥½ï¼Œè¯·ç®€å•ä»‹ç»ä¸€ä¸‹ä½ è‡ªå·±ã€‚"
        print(f"Test prompt: {test_prompt}")
        
        try:
            llm_response = await rag.llm_model_func(
                test_prompt,
                system_prompt="ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„åŠ©æ‰‹ã€‚"
            )
            print(f"âœ… LLM Response: {llm_response}\n")
        except Exception as e:
            print(f"âš ï¸ LLM æµ‹è¯•å¤±è´¥: {e}")
            print("å¯èƒ½åŸå› ï¼šsample_audio.py æœªè¿è¡Œæˆ–APIæœåŠ¡å™¨æœªå¯åŠ¨")
        
        # åˆ›å»ºç¤ºä¾‹é—®é¢˜æ–‡ä»¶
        create_example_question_file()
        
        # å¼€å§‹ç›‘æ§å’Œå¤„ç†é—®é¢˜
        print("\n" + "=" * 60)
        print("å¼€å§‹é—®é¢˜ç›‘æ§...")
        print("=" * 60)
        
        await monitor_and_process_questions(rag)
        
    except Exception as e:
        print(f"An error occurred: {e}")
        import traceback
        traceback.print_exc()
    finally:
        if 'rag' in locals():
            try:
                await rag.finalize_storages()
            except:
                pass

# ç¨‹åºå…¥å£ç‚¹
if __name__ == "__main__":
    # åœ¨è¿è¡Œä¸»å‡½æ•°å‰é…ç½®æ—¥å¿—
    configure_logging()
    
    print("ğŸš€ å¯åŠ¨ LightRAG with Qwen bmodel (æ··åˆæ¨¡å¼)")
    print("=" * 60)
    print("æ¶æ„è¯´æ˜:")
    print("- LLM: é€šè¿‡ HTTP API è®¿é—® (qwen_llm_adapter.py)")
    print("- Embedding: ç›´æ¥åŠ è½½æœ¬åœ° bmodel")
    print("- æ³¨æ„ï¼šè¯·ç¡®ä¿ sample_audio.py æ­£åœ¨è¿è¡Œä»¥æä¾›LLMæœåŠ¡")
    print("=" * 60)
    
    # è¿è¡Œå¼‚æ­¥ä¸»å‡½æ•°
    asyncio.run(main())
    
    # æ‰“å°å®Œæˆä¿¡æ¯
    print("\nDone! Qwen embedding bmodel integration with LightRAG completed successfully.")
'''
'''lightrag.py
from __future__ import annotations

import traceback
import asyncio
import configparser
import os
import time
import warnings
from dataclasses import asdict, dataclass, field
from datetime import datetime, timezone
from functools import partial
from typing import (
    Any,
    AsyncIterator,
    Callable,
    Iterator,
    cast,
    final,
    Literal,
    Optional,
    List,
    Dict,
)
from lightrag.constants import (
    DEFAULT_MAX_GLEANING,
    DEFAULT_FORCE_LLM_SUMMARY_ON_MERGE,
)
from lightrag.utils import get_env_value

from lightrag.kg import (
    STORAGES,
    verify_storage_implementation,
)

from lightrag.kg.shared_storage import (
    get_namespace_data,
    get_pipeline_status_lock,
    get_graph_db_lock,
)

from .base import (
    BaseGraphStorage,
    BaseKVStorage,
    BaseVectorStorage,
    DocProcessingStatus,
    DocStatus,
    DocStatusStorage,
    QueryParam,
    StorageNameSpace,
    StoragesStatus,
    DeletionResult,
)
from .namespace import NameSpace
from .operate import (
    chunking_by_token_size,
    extract_entities,
    merge_nodes_and_edges,
    kg_query,
    naive_query,
    query_with_keywords,
    _rebuild_knowledge_from_chunks,
)
from .constants import GRAPH_FIELD_SEP
from .utils import (
    Tokenizer,
    TiktokenTokenizer,
    EmbeddingFunc,
    always_get_an_event_loop,
    compute_mdhash_id,
    convert_response_to_json,
    lazy_external_import,
    priority_limit_async_func_call,
    get_content_summary,
    clean_text,
    check_storage_env_vars,
    logger,
)
from .types import KnowledgeGraph
from dotenv import load_dotenv

# use the .env that is inside the current folder
# allows to use different .env file for each lightrag instance
# the OS environment variables take precedence over the .env file
load_dotenv(dotenv_path=".env", override=False)

# TODO: TO REMOVE @Yannick
config = configparser.ConfigParser()
config.read("config.ini", "utf-8")


@final
@dataclass
class LightRAG:
    """LightRAG: Simple and Fast Retrieval-Augmented Generation."""

    # Directory
    # ---

    working_dir: str = field(default="./rag_storage")
    """Directory where cache and temporary files are stored."""

    # Storage
    # ---

    kv_storage: str = field(default="JsonKVStorage")
    """Storage backend for key-value data."""

    vector_storage: str = field(default="NanoVectorDBStorage")
    """Storage backend for vector embeddings."""

    graph_storage: str = field(default="NetworkXStorage")
    """Storage backend for knowledge graphs."""

    doc_status_storage: str = field(default="JsonDocStatusStorage")
    """Storage type for tracking document processing statuses."""

    # Workspace
    # ---

    workspace: str = field(default_factory=lambda: os.getenv("WORKSPACE", ""))
    """Workspace for data isolation. Defaults to empty string if WORKSPACE environment variable is not set."""

    # Logging (Deprecated, use setup_logger in utils.py instead)
    # ---
    log_level: int | None = field(default=None)
    log_file_path: str | None = field(default=None)

    # Entity extraction
    # ---

    entity_extract_max_gleaning: int = field(
        default=get_env_value("MAX_GLEANING", DEFAULT_MAX_GLEANING, int)
    )
    """Maximum number of entity extraction attempts for ambiguous content."""

    force_llm_summary_on_merge: int = field(
        default=get_env_value(
            "FORCE_LLM_SUMMARY_ON_MERGE", DEFAULT_FORCE_LLM_SUMMARY_ON_MERGE, int
        )
    )

    # Text chunking
    # ---

    chunk_token_size: int = field(default=int(os.getenv("CHUNK_SIZE", 1200)))
    """Maximum number of tokens per text chunk when splitting documents."""

    chunk_overlap_token_size: int = field(
        default=int(os.getenv("CHUNK_OVERLAP_SIZE", 100))
    )
    """Number of overlapping tokens between consecutive text chunks to preserve context."""

    tokenizer: Optional[Tokenizer] = field(default=None)
    """
    A function that returns a Tokenizer instance.
    If None, and a `tiktoken_model_name` is provided, a TiktokenTokenizer will be created.
    If both are None, the default TiktokenTokenizer is used.
    """

    tiktoken_model_name: str = field(default="gpt-4o-mini")
    """Model name used for tokenization when chunking text with tiktoken. Defaults to `gpt-4o-mini`."""

    chunking_func: Callable[
        [
            Tokenizer,
            str,
            Optional[str],
            bool,
            int,
            int,
        ],
        List[Dict[str, Any]],
    ] = field(default_factory=lambda: chunking_by_token_size)
    """
    Custom chunking function for splitting text into chunks before processing.

    The function should take the following parameters:

        - `tokenizer`: A Tokenizer instance to use for tokenization.
        - `content`: The text to be split into chunks.
        - `split_by_character`: The character to split the text on. If None, the text is split into chunks of `chunk_token_size` tokens.
        - `split_by_character_only`: If True, the text is split only on the specified character.
        - `chunk_token_size`: The maximum number of tokens per chunk.
        - `chunk_overlap_token_size`: The number of overlapping tokens between consecutive chunks.

    The function should return a list of dictionaries, where each dictionary contains the following keys:
        - `tokens`: The number of tokens in the chunk.
        - `content`: The text content of the chunk.

    Defaults to `chunking_by_token_size` if not specified.
    """

    # Embedding
    # ---

    embedding_func: EmbeddingFunc | None = field(default=None)
    """Function for computing text embeddings. Must be set before use."""

    embedding_batch_num: int = field(default=int(os.getenv("EMBEDDING_BATCH_NUM", 10)))
    """Batch size for embedding computations."""

    embedding_func_max_async: int = field(
        default=int(os.getenv("EMBEDDING_FUNC_MAX_ASYNC", 8))
    )
    """Maximum number of concurrent embedding function calls."""

    embedding_cache_config: dict[str, Any] = field(
        default_factory=lambda: {
            "enabled": False,
            "similarity_threshold": 0.95,
            "use_llm_check": False,
        }
    )
    """Configuration for embedding cache.
    - enabled: If True, enables caching to avoid redundant computations.
    - similarity_threshold: Minimum similarity score to use cached embeddings.
    - use_llm_check: If True, validates cached embeddings using an LLM.
    """

    # LLM Configuration
    # ---

    llm_model_func: Callable[..., object] | None = field(default=None)
    """Function for interacting with the large language model (LLM). Must be set before use."""

    llm_model_name: str = field(default="gpt-4o-mini")
    """Name of the LLM model used for generating responses."""

    llm_model_max_token_size: int = field(default=int(os.getenv("MAX_TOKENS", 32000)))
    """Maximum number of tokens allowed per LLM response."""

    llm_model_max_async: int = field(default=int(os.getenv("MAX_ASYNC", 4)))
    """Maximum number of concurrent LLM calls."""

    llm_model_kwargs: dict[str, Any] = field(default_factory=dict)
    """Additional keyword arguments passed to the LLM model function."""

    # Rerank Configuration
    # ---

    enable_rerank: bool = field(
        default=bool(os.getenv("ENABLE_RERANK", "False").lower() == "true")
    )
    """Enable reranking for improved retrieval quality. Defaults to False."""

    rerank_model_func: Callable[..., object] | None = field(default=None)
    """Function for reranking retrieved documents. All rerank configurations (model name, API keys, top_k, etc.) should be included in this function. Optional."""

    # Storage
    # ---

    vector_db_storage_cls_kwargs: dict[str, Any] = field(default_factory=dict)
    """Additional parameters for vector database storage."""

    enable_llm_cache: bool = field(default=True)
    """Enables caching for LLM responses to avoid redundant computations."""

    enable_llm_cache_for_entity_extract: bool = field(default=True)
    """If True, enables caching for entity extraction steps to reduce LLM costs."""

    # Extensions
    # ---

    max_parallel_insert: int = field(default=int(os.getenv("MAX_PARALLEL_INSERT", 2)))
    """Maximum number of parallel insert operations."""

    max_graph_nodes: int = field(default=get_env_value("MAX_GRAPH_NODES", 1000, int))
    """Maximum number of graph nodes to return in knowledge graph queries."""

    addon_params: dict[str, Any] = field(
        default_factory=lambda: {
            "language": get_env_value("SUMMARY_LANGUAGE", "English", str)
        }
    )

    # Storages Management
    # ---

    auto_manage_storages_states: bool = field(default=True)
    """If True, lightrag will automatically calls initialize_storages and finalize_storages at the appropriate times."""

    # Storages Management
    # ---

    convert_response_to_json_func: Callable[[str], dict[str, Any]] = field(
        default_factory=lambda: convert_response_to_json
    )
    """
    Custom function for converting LLM responses to JSON format.

    The default function is :func:`.utils.convert_response_to_json`.
    """

    cosine_better_than_threshold: float = field(
        default=float(os.getenv("COSINE_THRESHOLD", 0.2))
    )

    _storages_status: StoragesStatus = field(default=StoragesStatus.NOT_CREATED)

    def __post_init__(self):
        from lightrag.kg.shared_storage import (
            initialize_share_data,
        )

        # Handle deprecated parameters
        if self.log_level is not None:
            warnings.warn(
                "WARNING: log_level parameter is deprecated, use setup_logger in utils.py instead",
                UserWarning,
                stacklevel=2,
            )
        if self.log_file_path is not None:
            warnings.warn(
                "WARNING: log_file_path parameter is deprecated, use setup_logger in utils.py instead",
                UserWarning,
                stacklevel=2,
            )

        # Remove these attributes to prevent their use
        if hasattr(self, "log_level"):
            delattr(self, "log_level")
        if hasattr(self, "log_file_path"):
            delattr(self, "log_file_path")

        initialize_share_data()

        if not os.path.exists(self.working_dir):
            logger.info(f"Creating working directory {self.working_dir}")
            os.makedirs(self.working_dir)

        # Verify storage implementation compatibility and environment variables
        storage_configs = [
            ("KV_STORAGE", self.kv_storage),
            ("VECTOR_STORAGE", self.vector_storage),
            ("GRAPH_STORAGE", self.graph_storage),
            ("DOC_STATUS_STORAGE", self.doc_status_storage),
        ]

        for storage_type, storage_name in storage_configs:
            # Verify storage implementation compatibility
            verify_storage_implementation(storage_type, storage_name)
            # Check environment variables
            check_storage_env_vars(storage_name)

        # Ensure vector_db_storage_cls_kwargs has required fields
        self.vector_db_storage_cls_kwargs = {
            "cosine_better_than_threshold": self.cosine_better_than_threshold,
            **self.vector_db_storage_cls_kwargs,
        }

        # Init Tokenizer
        # Post-initialization hook to handle backward compatabile tokenizer initialization based on provided parameters
        if self.tokenizer is None:
            if self.tiktoken_model_name:
                self.tokenizer = TiktokenTokenizer(self.tiktoken_model_name)
            else:
                self.tokenizer = TiktokenTokenizer()

        # Fix global_config now
        global_config = asdict(self)

        _print_config = ",\n  ".join([f"{k} = {v}" for k, v in global_config.items()])
        logger.debug(f"LightRAG init with param:\n  {_print_config}\n")

        # Init Embedding
        self.embedding_func = priority_limit_async_func_call(
            self.embedding_func_max_async
        )(self.embedding_func)

        # Initialize all storages
        self.key_string_value_json_storage_cls: type[BaseKVStorage] = (
            self._get_storage_class(self.kv_storage)
        )  # type: ignore
        self.vector_db_storage_cls: type[BaseVectorStorage] = self._get_storage_class(
            self.vector_storage
        )  # type: ignore
        self.graph_storage_cls: type[BaseGraphStorage] = self._get_storage_class(
            self.graph_storage
        )  # type: ignore
        self.key_string_value_json_storage_cls = partial(  # type: ignore
            self.key_string_value_json_storage_cls, global_config=global_config
        )
        self.vector_db_storage_cls = partial(  # type: ignore
            self.vector_db_storage_cls, global_config=global_config
        )
        self.graph_storage_cls = partial(  # type: ignore
            self.graph_storage_cls, global_config=global_config
        )

        # Initialize document status storage
        self.doc_status_storage_cls = self._get_storage_class(self.doc_status_storage)

        self.llm_response_cache: BaseKVStorage = self.key_string_value_json_storage_cls(  # type: ignore
            namespace=NameSpace.KV_STORE_LLM_RESPONSE_CACHE,
            workspace=self.workspace,
            global_config=global_config,
            embedding_func=self.embedding_func,
        )

        self.full_docs: BaseKVStorage = self.key_string_value_json_storage_cls(  # type: ignore
            namespace=NameSpace.KV_STORE_FULL_DOCS,
            workspace=self.workspace,
            embedding_func=self.embedding_func,
        )

        self.text_chunks: BaseKVStorage = self.key_string_value_json_storage_cls(  # type: ignore
            namespace=NameSpace.KV_STORE_TEXT_CHUNKS,
            workspace=self.workspace,
            embedding_func=self.embedding_func,
        )

        self.chunk_entity_relation_graph: BaseGraphStorage = self.graph_storage_cls(  # type: ignore
            namespace=NameSpace.GRAPH_STORE_CHUNK_ENTITY_RELATION,
            workspace=self.workspace,
            embedding_func=self.embedding_func,
        )

        self.entities_vdb: BaseVectorStorage = self.vector_db_storage_cls(  # type: ignore
            namespace=NameSpace.VECTOR_STORE_ENTITIES,
            workspace=self.workspace,
            embedding_func=self.embedding_func,
            meta_fields={"entity_name", "source_id", "content", "file_path"},
        )
        self.relationships_vdb: BaseVectorStorage = self.vector_db_storage_cls(  # type: ignore
            namespace=NameSpace.VECTOR_STORE_RELATIONSHIPS,
            workspace=self.workspace,
            embedding_func=self.embedding_func,
            meta_fields={"src_id", "tgt_id", "source_id", "content", "file_path"},
        )
        self.chunks_vdb: BaseVectorStorage = self.vector_db_storage_cls(  # type: ignore
            namespace=NameSpace.VECTOR_STORE_CHUNKS,
            workspace=self.workspace,
            embedding_func=self.embedding_func,
            meta_fields={"full_doc_id", "content", "file_path"},
        )

        # Initialize document status storage
        self.doc_status: DocStatusStorage = self.doc_status_storage_cls(
            namespace=NameSpace.DOC_STATUS,
            workspace=self.workspace,
            global_config=global_config,
            embedding_func=None,
        )

        # Directly use llm_response_cache, don't create a new object
        hashing_kv = self.llm_response_cache

        self.llm_model_func = priority_limit_async_func_call(self.llm_model_max_async)(
            partial(
                self.llm_model_func,  # type: ignore
                hashing_kv=hashing_kv,
                **self.llm_model_kwargs,
            )
        )

        # Init Rerank
        if self.enable_rerank and self.rerank_model_func:
            logger.info("Rerank model initialized for improved retrieval quality")
        elif self.enable_rerank and not self.rerank_model_func:
            logger.warning(
                "Rerank is enabled but no rerank_model_func provided. Reranking will be skipped."
            )

        self._storages_status = StoragesStatus.CREATED

        if self.auto_manage_storages_states:
            self._run_async_safely(self.initialize_storages, "Storage Initialization")

    def __del__(self):
        if self.auto_manage_storages_states:
            self._run_async_safely(self.finalize_storages, "Storage Finalization")

    def _run_async_safely(self, async_func, action_name=""):
        """Safely execute an async function, avoiding event loop conflicts."""
        try:
            loop = always_get_an_event_loop()
            if loop.is_running():
                task = loop.create_task(async_func())
                task.add_done_callback(
                    lambda t: logger.info(f"{action_name} completed!")
                )
            else:
                loop.run_until_complete(async_func())
        except RuntimeError:
            logger.warning(
                f"No running event loop, creating a new loop for {action_name}."
            )
            loop = asyncio.new_event_loop()
            loop.run_until_complete(async_func())
            loop.close()

    async def initialize_storages(self):
        """Asynchronously initialize the storages"""
        if self._storages_status == StoragesStatus.CREATED:
            tasks = []

            for storage in (
                self.full_docs,
                self.text_chunks,
                self.entities_vdb,
                self.relationships_vdb,
                self.chunks_vdb,
                self.chunk_entity_relation_graph,
                self.llm_response_cache,
                self.doc_status,
            ):
                if storage:
                    tasks.append(storage.initialize())

            await asyncio.gather(*tasks)

            self._storages_status = StoragesStatus.INITIALIZED
            logger.debug("Initialized Storages")

    async def finalize_storages(self):
        """Asynchronously finalize the storages"""
        if self._storages_status == StoragesStatus.INITIALIZED:
            tasks = []

            for storage in (
                self.full_docs,
                self.text_chunks,
                self.entities_vdb,
                self.relationships_vdb,
                self.chunks_vdb,
                self.chunk_entity_relation_graph,
                self.llm_response_cache,
                self.doc_status,
            ):
                if storage:
                    tasks.append(storage.finalize())

            await asyncio.gather(*tasks)

            self._storages_status = StoragesStatus.FINALIZED
            logger.debug("Finalized Storages")

    async def get_graph_labels(self):
        text = await self.chunk_entity_relation_graph.get_all_labels()
        return text

    async def get_knowledge_graph(
        self,
        node_label: str,
        max_depth: int = 3,
        max_nodes: int = None,
    ) -> KnowledgeGraph:
        """Get knowledge graph for a given label

        Args:
            node_label (str): Label to get knowledge graph for
            max_depth (int): Maximum depth of graph
            max_nodes (int, optional): Maximum number of nodes to return. Defaults to self.max_graph_nodes.

        Returns:
            KnowledgeGraph: Knowledge graph containing nodes and edges
        """
        # Use self.max_graph_nodes as default if max_nodes is None
        if max_nodes is None:
            max_nodes = self.max_graph_nodes
        else:
            # Limit max_nodes to not exceed self.max_graph_nodes
            max_nodes = min(max_nodes, self.max_graph_nodes)

        return await self.chunk_entity_relation_graph.get_knowledge_graph(
            node_label, max_depth, max_nodes
        )

    def _get_storage_class(self, storage_name: str) -> Callable[..., Any]:
        import_path = STORAGES[storage_name]
        storage_class = lazy_external_import(import_path, storage_name)
        return storage_class

    def insert(
        self,
        input: str | list[str],
        split_by_character: str | None = None,
        split_by_character_only: bool = False,
        ids: str | list[str] | None = None,
        file_paths: str | list[str] | None = None,
    ) -> None:
        """Sync Insert documents with checkpoint support

        Args:
            input: Single document string or list of document strings
            split_by_character: if split_by_character is not None, split the string by character, if chunk longer than
            chunk_token_size, it will be split again by token size.
            split_by_character_only: if split_by_character_only is True, split the string by character only, when
            split_by_character is None, this parameter is ignored.
            ids: single string of the document ID or list of unique document IDs, if not provided, MD5 hash IDs will be generated
            file_paths: single string of the file path or list of file paths, used for citation
        """
        loop = always_get_an_event_loop()
        loop.run_until_complete(
            self.ainsert(
                input, split_by_character, split_by_character_only, ids, file_paths
            )
        )

    async def ainsert(
        self,
        input: str | list[str],
        split_by_character: str | None = None,
        split_by_character_only: bool = False,
        ids: str | list[str] | None = None,
        file_paths: str | list[str] | None = None,
    ) -> None:
        """Async Insert documents with checkpoint support

        Args:
            input: Single document string or list of document strings
            split_by_character: if split_by_character is not None, split the string by character, if chunk longer than
            chunk_token_size, it will be split again by token size.
            split_by_character_only: if split_by_character_only is True, split the string by character only, when
            split_by_character is None, this parameter is ignored.
            ids: list of unique document IDs, if not provided, MD5 hash IDs will be generated
            file_paths: list of file paths corresponding to each document, used for citation
        """
        await self.apipeline_enqueue_documents(input, ids, file_paths)
        await self.apipeline_process_enqueue_documents(
            split_by_character, split_by_character_only
        )

    # TODO: deprecated, use insert instead
    def insert_custom_chunks(
        self,
        full_text: str,
        text_chunks: list[str],
        doc_id: str | list[str] | None = None,
    ) -> None:
        loop = always_get_an_event_loop()
        loop.run_until_complete(
            self.ainsert_custom_chunks(full_text, text_chunks, doc_id)
        )

    # TODO: deprecated, use ainsert instead
    async def ainsert_custom_chunks(
        self, full_text: str, text_chunks: list[str], doc_id: str | None = None
    ) -> None:
        update_storage = False
        try:
            # Clean input texts
            full_text = clean_text(full_text)
            text_chunks = [clean_text(chunk) for chunk in text_chunks]
            file_path = ""

            # Process cleaned texts
            if doc_id is None:
                doc_key = compute_mdhash_id(full_text, prefix="doc-")
            else:
                doc_key = doc_id
            new_docs = {doc_key: {"content": full_text}}

            _add_doc_keys = await self.full_docs.filter_keys({doc_key})
            new_docs = {k: v for k, v in new_docs.items() if k in _add_doc_keys}
            if not len(new_docs):
                logger.warning("This document is already in the storage.")
                return

            update_storage = True
            logger.info(f"Inserting {len(new_docs)} docs")

            inserting_chunks: dict[str, Any] = {}
            for index, chunk_text in enumerate(text_chunks):
                chunk_key = compute_mdhash_id(chunk_text, prefix="chunk-")
                tokens = len(self.tokenizer.encode(chunk_text))
                inserting_chunks[chunk_key] = {
                    "content": chunk_text,
                    "full_doc_id": doc_key,
                    "tokens": tokens,
                    "chunk_order_index": index,
                    "file_path": file_path,
                }

            doc_ids = set(inserting_chunks.keys())
            add_chunk_keys = await self.text_chunks.filter_keys(doc_ids)
            inserting_chunks = {
                k: v for k, v in inserting_chunks.items() if k in add_chunk_keys
            }
            if not len(inserting_chunks):
                logger.warning("All chunks are already in the storage.")
                return

            tasks = [
                self.chunks_vdb.upsert(inserting_chunks),
                self._process_entity_relation_graph(inserting_chunks),
                self.full_docs.upsert(new_docs),
                self.text_chunks.upsert(inserting_chunks),
            ]
            await asyncio.gather(*tasks)

        finally:
            if update_storage:
                await self._insert_done()

    async def apipeline_enqueue_documents(
        self,
        input: str | list[str],
        ids: list[str] | None = None,
        file_paths: str | list[str] | None = None,
    ) -> None:
        """
        Pipeline for Processing Documents

        1. Validate ids if provided or generate MD5 hash IDs
        2. Remove duplicate contents
        3. Generate document initial status
        4. Filter out already processed documents
        5. Enqueue document in status

        Args:
            input: Single document string or list of document strings
            ids: list of unique document IDs, if not provided, MD5 hash IDs will be generated
            file_paths: list of file paths corresponding to each document, used for citation
        """
        if isinstance(input, str):
            input = [input]
        if isinstance(ids, str):
            ids = [ids]
        if isinstance(file_paths, str):
            file_paths = [file_paths]

        # If file_paths is provided, ensure it matches the number of documents
        if file_paths is not None:
            if isinstance(file_paths, str):
                file_paths = [file_paths]
            if len(file_paths) != len(input):
                raise ValueError(
                    "Number of file paths must match the number of documents"
                )
        else:
            # If no file paths provided, use placeholder
            file_paths = ["unknown_source"] * len(input)

        # 1. Validate ids if provided or generate MD5 hash IDs
        if ids is not None:
            # Check if the number of IDs matches the number of documents
            if len(ids) != len(input):
                raise ValueError("Number of IDs must match the number of documents")

            # Check if IDs are unique
            if len(ids) != len(set(ids)):
                raise ValueError("IDs must be unique")

            # Generate contents dict of IDs provided by user and documents
            contents = {
                id_: {"content": doc, "file_path": path}
                for id_, doc, path in zip(ids, input, file_paths)
            }
        else:
            # Clean input text and remove duplicates
            cleaned_input = [
                (clean_text(doc), path) for doc, path in zip(input, file_paths)
            ]
            unique_content_with_paths = {}

            # Keep track of unique content and their paths
            for content, path in cleaned_input:
                if content not in unique_content_with_paths:
                    unique_content_with_paths[content] = path

            # Generate contents dict of MD5 hash IDs and documents with paths
            contents = {
                compute_mdhash_id(content, prefix="doc-"): {
                    "content": content,
                    "file_path": path,
                }
                for content, path in unique_content_with_paths.items()
            }

        # 2. Remove duplicate contents
        unique_contents = {}
        for id_, content_data in contents.items():
            content = content_data["content"]
            file_path = content_data["file_path"]
            if content not in unique_contents:
                unique_contents[content] = (id_, file_path)

        # Reconstruct contents with unique content
        contents = {
            id_: {"content": content, "file_path": file_path}
            for content, (id_, file_path) in unique_contents.items()
        }

        # 3. Generate document initial status
        new_docs: dict[str, Any] = {
            id_: {
                "status": DocStatus.PENDING,
                "content": content_data["content"],
                "content_summary": get_content_summary(content_data["content"]),
                "content_length": len(content_data["content"]),
                "created_at": datetime.now(timezone.utc).isoformat(),
                "updated_at": datetime.now(timezone.utc).isoformat(),
                "file_path": content_data[
                    "file_path"
                ],  # Store file path in document status
            }
            for id_, content_data in contents.items()
        }

        # 4. Filter out already processed documents
        # Get docs ids
        all_new_doc_ids = set(new_docs.keys())
        # Exclude IDs of documents that are already in progress
        unique_new_doc_ids = await self.doc_status.filter_keys(all_new_doc_ids)

        # Log ignored document IDs
        ignored_ids = [
            doc_id for doc_id in unique_new_doc_ids if doc_id not in new_docs
        ]
        if ignored_ids:
            logger.warning(
                f"Ignoring {len(ignored_ids)} document IDs not found in new_docs"
            )
            for doc_id in ignored_ids:
                logger.warning(f"Ignored document ID: {doc_id}")

        # Filter new_docs to only include documents with unique IDs
        new_docs = {
            doc_id: new_docs[doc_id]
            for doc_id in unique_new_doc_ids
            if doc_id in new_docs
        }

        if not new_docs:
            logger.info("No new unique documents were found.")
            return

        # 5. Store status document
        await self.doc_status.upsert(new_docs)
        logger.info(f"Stored {len(new_docs)} new unique documents")

    async def apipeline_process_enqueue_documents(
        self,
        split_by_character: str | None = None,
        split_by_character_only: bool = False,
    ) -> None:
        """
        Process pending documents by splitting them into chunks, processing
        each chunk for entity and relation extraction, and updating the
        document status.

        1. Get all pending, failed, and abnormally terminated processing documents.
        2. Split document content into chunks
        3. Process each chunk for entity and relation extraction
        4. Update the document status
        """

        # Get pipeline status shared data and lock
        pipeline_status = await get_namespace_data("pipeline_status")
        pipeline_status_lock = get_pipeline_status_lock()

        # Check if another process is already processing the queue
        async with pipeline_status_lock:
            # Ensure only one worker is processing documents
            if not pipeline_status.get("busy", False):
                processing_docs, failed_docs, pending_docs = await asyncio.gather(
                    self.doc_status.get_docs_by_status(DocStatus.PROCESSING),
                    self.doc_status.get_docs_by_status(DocStatus.FAILED),
                    self.doc_status.get_docs_by_status(DocStatus.PENDING),
                )

                to_process_docs: dict[str, DocProcessingStatus] = {}
                to_process_docs.update(processing_docs)
                to_process_docs.update(failed_docs)
                to_process_docs.update(pending_docs)

                if not to_process_docs:
                    logger.info("No documents to process")
                    return

                pipeline_status.update(
                    {
                        "busy": True,
                        "job_name": "Default Job",
                        "job_start": datetime.now(timezone.utc).isoformat(),
                        "docs": 0,
                        "batchs": 0,  # Total number of files to be processed
                        "cur_batch": 0,  # Number of files already processed
                        "request_pending": False,  # Clear any previous request
                        "latest_message": "",
                    }
                )
                # Cleaning history_messages without breaking it as a shared list object
                del pipeline_status["history_messages"][:]
            else:
                # Another process is busy, just set request flag and return
                pipeline_status["request_pending"] = True
                logger.info(
                    "Another process is already processing the document queue. Request queued."
                )
                return

        try:
            # Process documents until no more documents or requests
            while True:
                if not to_process_docs:
                    log_message = "All documents have been processed or are duplicates"
                    logger.info(log_message)
                    pipeline_status["latest_message"] = log_message
                    pipeline_status["history_messages"].append(log_message)
                    break

                log_message = f"Processing {len(to_process_docs)} document(s)"
                logger.info(log_message)

                # Update pipeline_status, batchs now represents the total number of files to be processed
                pipeline_status["docs"] = len(to_process_docs)
                pipeline_status["batchs"] = len(to_process_docs)
                pipeline_status["cur_batch"] = 0
                pipeline_status["latest_message"] = log_message
                pipeline_status["history_messages"].append(log_message)

                # Get first document's file path and total count for job name
                first_doc_id, first_doc = next(iter(to_process_docs.items()))
                first_doc_path = first_doc.file_path

                # Handle cases where first_doc_path is None
                if first_doc_path:
                    path_prefix = first_doc_path[:20] + (
                        "..." if len(first_doc_path) > 20 else ""
                    )
                else:
                    path_prefix = "unknown_source"

                total_files = len(to_process_docs)
                job_name = f"{path_prefix}[{total_files} files]"
                pipeline_status["job_name"] = job_name

                # Create a counter to track the number of processed files
                processed_count = 0
                # Create a semaphore to limit the number of concurrent file processing
                semaphore = asyncio.Semaphore(self.max_parallel_insert)

                async def process_document(
                    doc_id: str,
                    status_doc: DocProcessingStatus,
                    split_by_character: str | None,
                    split_by_character_only: bool,
                    pipeline_status: dict,
                    pipeline_status_lock: asyncio.Lock,
                    semaphore: asyncio.Semaphore,
                ) -> None:
                    """Process single document"""
                    file_extraction_stage_ok = False
                    async with semaphore:
                        nonlocal processed_count
                        current_file_number = 0
                        try:
                            # Get file path from status document
                            file_path = getattr(
                                status_doc, "file_path", "unknown_source"
                            )

                            async with pipeline_status_lock:
                                # Update processed file count and save current file number
                                processed_count += 1
                                current_file_number = (
                                    processed_count  # Save the current file number
                                )
                                pipeline_status["cur_batch"] = processed_count

                                log_message = f"Extracting stage {current_file_number}/{total_files}: {file_path}"
                                logger.info(log_message)
                                pipeline_status["history_messages"].append(log_message)
                                log_message = f"Processing d-id: {doc_id}"
                                logger.info(log_message)
                                pipeline_status["latest_message"] = log_message
                                pipeline_status["history_messages"].append(log_message)

                            # Generate chunks from document
                            chunks: dict[str, Any] = {
                                compute_mdhash_id(dp["content"], prefix="chunk-"): {
                                    **dp,
                                    "full_doc_id": doc_id,
                                    "file_path": file_path,  # Add file path to each chunk
                                    "llm_cache_list": [],  # Initialize empty LLM cache list for each chunk
                                }
                                for dp in self.chunking_func(
                                    self.tokenizer,
                                    status_doc.content,
                                    split_by_character,
                                    split_by_character_only,
                                    self.chunk_overlap_token_size,
                                    self.chunk_token_size,
                                )
                            }

                            if not chunks:
                                logger.warning("No document chunks to process")

                            # Process document in two stages
                            # Stage 1: Process text chunks and docs (parallel execution)
                            doc_status_task = asyncio.create_task(
                                self.doc_status.upsert(
                                    {
                                        doc_id: {
                                            "status": DocStatus.PROCESSING,
                                            "chunks_count": len(chunks),
                                            "chunks_list": list(
                                                chunks.keys()
                                            ),  # Save chunks list
                                            "content": status_doc.content,
                                            "content_summary": status_doc.content_summary,
                                            "content_length": status_doc.content_length,
                                            "created_at": status_doc.created_at,
                                            "updated_at": datetime.now(
                                                timezone.utc
                                            ).isoformat(),
                                            "file_path": file_path,
                                        }
                                    }
                                )
                            )
                            chunks_vdb_task = asyncio.create_task(
                                self.chunks_vdb.upsert(chunks)
                            )
                            full_docs_task = asyncio.create_task(
                                self.full_docs.upsert(
                                    {doc_id: {"content": status_doc.content}}
                                )
                            )
                            text_chunks_task = asyncio.create_task(
                                self.text_chunks.upsert(chunks)
                            )

                            # First stage tasks (parallel execution)
                            first_stage_tasks = [
                                doc_status_task,
                                chunks_vdb_task,
                                full_docs_task,
                                text_chunks_task,
                            ]
                            entity_relation_task = None

                            # Execute first stage tasks
                            await asyncio.gather(*first_stage_tasks)

                            # Stage 2: Process entity relation graph (after text_chunks are saved)
                            entity_relation_task = asyncio.create_task(
                                self._process_entity_relation_graph(
                                    chunks, pipeline_status, pipeline_status_lock
                                )
                            )
                            await entity_relation_task
                            file_extraction_stage_ok = True

                        except Exception as e:
                            # Log error and update pipeline status
                            logger.error(traceback.format_exc())
                            error_msg = f"Failed to extract document {current_file_number}/{total_files}: {file_path}"
                            logger.error(error_msg)
                            async with pipeline_status_lock:
                                pipeline_status["latest_message"] = error_msg
                                pipeline_status["history_messages"].append(
                                    traceback.format_exc()
                                )
                                pipeline_status["history_messages"].append(error_msg)

                                # Cancel tasks that are not yet completed
                                all_tasks = first_stage_tasks + (
                                    [entity_relation_task]
                                    if entity_relation_task
                                    else []
                                )
                                for task in all_tasks:
                                    if task and not task.done():
                                        task.cancel()

                            # Persistent llm cache
                            if self.llm_response_cache:
                                await self.llm_response_cache.index_done_callback()

                            # Update document status to failed
                            await self.doc_status.upsert(
                                {
                                    doc_id: {
                                        "status": DocStatus.FAILED,
                                        "error": str(e),
                                        "content": status_doc.content,
                                        "content_summary": status_doc.content_summary,
                                        "content_length": status_doc.content_length,
                                        "created_at": status_doc.created_at,
                                        "updated_at": datetime.now(
                                            timezone.utc
                                        ).isoformat(),
                                        "file_path": file_path,
                                    }
                                }
                            )

                        # Concurrency is controlled by graph db lock for individual entities and relationships
                        if file_extraction_stage_ok:
                            try:
                                # Get chunk_results from entity_relation_task
                                chunk_results = await entity_relation_task
                                await merge_nodes_and_edges(
                                    chunk_results=chunk_results,  # result collected from entity_relation_task
                                    knowledge_graph_inst=self.chunk_entity_relation_graph,
                                    entity_vdb=self.entities_vdb,
                                    relationships_vdb=self.relationships_vdb,
                                    global_config=asdict(self),
                                    pipeline_status=pipeline_status,
                                    pipeline_status_lock=pipeline_status_lock,
                                    llm_response_cache=self.llm_response_cache,
                                    current_file_number=current_file_number,
                                    total_files=total_files,
                                    file_path=file_path,
                                )

                                await self.doc_status.upsert(
                                    {
                                        doc_id: {
                                            "status": DocStatus.PROCESSED,
                                            "chunks_count": len(chunks),
                                            "chunks_list": list(
                                                chunks.keys()
                                            ),  # ä¿ç•™ chunks_list
                                            "content": status_doc.content,
                                            "content_summary": status_doc.content_summary,
                                            "content_length": status_doc.content_length,
                                            "created_at": status_doc.created_at,
                                            "updated_at": datetime.now(
                                                timezone.utc
                                            ).isoformat(),
                                            "file_path": file_path,
                                        }
                                    }
                                )

                                # Call _insert_done after processing each file
                                await self._insert_done()

                                async with pipeline_status_lock:
                                    log_message = f"Completed processing file {current_file_number}/{total_files}: {file_path}"
                                    logger.info(log_message)
                                    pipeline_status["latest_message"] = log_message
                                    pipeline_status["history_messages"].append(
                                        log_message
                                    )

                            except Exception as e:
                                # Log error and update pipeline status
                                logger.error(traceback.format_exc())
                                error_msg = f"Merging stage failed in document {current_file_number}/{total_files}: {file_path}"
                                logger.error(error_msg)
                                async with pipeline_status_lock:
                                    pipeline_status["latest_message"] = error_msg
                                    pipeline_status["history_messages"].append(
                                        traceback.format_exc()
                                    )
                                    pipeline_status["history_messages"].append(
                                        error_msg
                                    )

                                # Persistent llm cache
                                if self.llm_response_cache:
                                    await self.llm_response_cache.index_done_callback()

                                # Update document status to failed
                                await self.doc_status.upsert(
                                    {
                                        doc_id: {
                                            "status": DocStatus.FAILED,
                                            "error": str(e),
                                            "content": status_doc.content,
                                            "content_summary": status_doc.content_summary,
                                            "content_length": status_doc.content_length,
                                            "created_at": status_doc.created_at,
                                            "updated_at": datetime.now().isoformat(),
                                            "file_path": file_path,
                                        }
                                    }
                                )

                # Create processing tasks for all documents
                doc_tasks = []
                for doc_id, status_doc in to_process_docs.items():
                    doc_tasks.append(
                        process_document(
                            doc_id,
                            status_doc,
                            split_by_character,
                            split_by_character_only,
                            pipeline_status,
                            pipeline_status_lock,
                            semaphore,
                        )
                    )

                # Wait for all document processing to complete
                await asyncio.gather(*doc_tasks)

                # Check if there's a pending request to process more documents (with lock)
                has_pending_request = False
                async with pipeline_status_lock:
                    has_pending_request = pipeline_status.get("request_pending", False)
                    if has_pending_request:
                        # Clear the request flag before checking for more documents
                        pipeline_status["request_pending"] = False

                if not has_pending_request:
                    break

                log_message = "Processing additional documents due to pending request"
                logger.info(log_message)
                pipeline_status["latest_message"] = log_message
                pipeline_status["history_messages"].append(log_message)

                # Check for pending documents again
                processing_docs, failed_docs, pending_docs = await asyncio.gather(
                    self.doc_status.get_docs_by_status(DocStatus.PROCESSING),
                    self.doc_status.get_docs_by_status(DocStatus.FAILED),
                    self.doc_status.get_docs_by_status(DocStatus.PENDING),
                )

                to_process_docs = {}
                to_process_docs.update(processing_docs)
                to_process_docs.update(failed_docs)
                to_process_docs.update(pending_docs)

        finally:
            log_message = "Document processing pipeline completed"
            logger.info(log_message)
            # Always reset busy status when done or if an exception occurs (with lock)
            async with pipeline_status_lock:
                pipeline_status["busy"] = False
                pipeline_status["latest_message"] = log_message
                pipeline_status["history_messages"].append(log_message)

    async def _process_entity_relation_graph(
        self, chunk: dict[str, Any], pipeline_status=None, pipeline_status_lock=None
    ) -> list:
        try:
            chunk_results = await extract_entities(
                chunk,
                global_config=asdict(self),
                pipeline_status=pipeline_status,
                pipeline_status_lock=pipeline_status_lock,
                llm_response_cache=self.llm_response_cache,
                text_chunks_storage=self.text_chunks,
            )
            return chunk_results
        except Exception as e:
            error_msg = f"Failed to extract entities and relationships: {str(e)}"
            logger.error(error_msg)
            async with pipeline_status_lock:
                pipeline_status["latest_message"] = error_msg
                pipeline_status["history_messages"].append(error_msg)
            raise e

    async def _insert_done(
        self, pipeline_status=None, pipeline_status_lock=None
    ) -> None:
        tasks = [
            cast(StorageNameSpace, storage_inst).index_done_callback()
            for storage_inst in [  # type: ignore
                self.full_docs,
                self.doc_status,
                self.text_chunks,
                self.llm_response_cache,
                self.entities_vdb,
                self.relationships_vdb,
                self.chunks_vdb,
                self.chunk_entity_relation_graph,
            ]
            if storage_inst is not None
        ]
        await asyncio.gather(*tasks)

        log_message = "In memory DB persist to disk"
        logger.info(log_message)

        if pipeline_status is not None and pipeline_status_lock is not None:
            async with pipeline_status_lock:
                pipeline_status["latest_message"] = log_message
                pipeline_status["history_messages"].append(log_message)

    def insert_custom_kg(
        self, custom_kg: dict[str, Any], full_doc_id: str = None
    ) -> None:
        loop = always_get_an_event_loop()
        loop.run_until_complete(self.ainsert_custom_kg(custom_kg, full_doc_id))

    async def ainsert_custom_kg(
        self,
        custom_kg: dict[str, Any],
        full_doc_id: str = None,
    ) -> None:
        update_storage = False
        try:
            # Insert chunks into vector storage
            all_chunks_data: dict[str, dict[str, str]] = {}
            chunk_to_source_map: dict[str, str] = {}
            for chunk_data in custom_kg.get("chunks", []):
                chunk_content = clean_text(chunk_data["content"])
                source_id = chunk_data["source_id"]
                file_path = chunk_data.get("file_path", "custom_kg")
                tokens = len(self.tokenizer.encode(chunk_content))
                chunk_order_index = (
                    0
                    if "chunk_order_index" not in chunk_data.keys()
                    else chunk_data["chunk_order_index"]
                )
                chunk_id = compute_mdhash_id(chunk_content, prefix="chunk-")

                chunk_entry = {
                    "content": chunk_content,
                    "source_id": source_id,
                    "tokens": tokens,
                    "chunk_order_index": chunk_order_index,
                    "full_doc_id": full_doc_id
                    if full_doc_id is not None
                    else source_id,
                    "file_path": file_path,
                    "status": DocStatus.PROCESSED,
                }
                all_chunks_data[chunk_id] = chunk_entry
                chunk_to_source_map[source_id] = chunk_id
                update_storage = True

            if all_chunks_data:
                await asyncio.gather(
                    self.chunks_vdb.upsert(all_chunks_data),
                    self.text_chunks.upsert(all_chunks_data),
                )

            # Insert entities into knowledge graph
            all_entities_data: list[dict[str, str]] = []
            for entity_data in custom_kg.get("entities", []):
                entity_name = entity_data["entity_name"]
                entity_type = entity_data.get("entity_type", "UNKNOWN")
                description = entity_data.get("description", "No description provided")
                source_chunk_id = entity_data.get("source_id", "UNKNOWN")
                source_id = chunk_to_source_map.get(source_chunk_id, "UNKNOWN")
                file_path = entity_data.get("file_path", "custom_kg")

                # Log if source_id is UNKNOWN
                if source_id == "UNKNOWN":
                    logger.warning(
                        f"Entity '{entity_name}' has an UNKNOWN source_id. Please check the source mapping."
                    )

                # Prepare node data
                node_data: dict[str, str] = {
                    "entity_id": entity_name,
                    "entity_type": entity_type,
                    "description": description,
                    "source_id": source_id,
                    "file_path": file_path,
                    "created_at": int(time.time()),
                }
                # Insert node data into the knowledge graph
                await self.chunk_entity_relation_graph.upsert_node(
                    entity_name, node_data=node_data
                )
                node_data["entity_name"] = entity_name
                all_entities_data.append(node_data)
                update_storage = True

            # Insert relationships into knowledge graph
            all_relationships_data: list[dict[str, str]] = []
            for relationship_data in custom_kg.get("relationships", []):
                src_id = relationship_data["src_id"]
                tgt_id = relationship_data["tgt_id"]
                description = relationship_data["description"]
                keywords = relationship_data["keywords"]
                weight = relationship_data.get("weight", 1.0)
                source_chunk_id = relationship_data.get("source_id", "UNKNOWN")
                source_id = chunk_to_source_map.get(source_chunk_id, "UNKNOWN")
                file_path = relationship_data.get("file_path", "custom_kg")

                # Log if source_id is UNKNOWN
                if source_id == "UNKNOWN":
                    logger.warning(
                        f"Relationship from '{src_id}' to '{tgt_id}' has an UNKNOWN source_id. Please check the source mapping."
                    )

                # Check if nodes exist in the knowledge graph
                for need_insert_id in [src_id, tgt_id]:
                    if not (
                        await self.chunk_entity_relation_graph.has_node(need_insert_id)
                    ):
                        await self.chunk_entity_relation_graph.upsert_node(
                            need_insert_id,
                            node_data={
                                "entity_id": need_insert_id,
                                "source_id": source_id,
                                "description": "UNKNOWN",
                                "entity_type": "UNKNOWN",
                                "file_path": file_path,
                                "created_at": int(time.time()),
                            },
                        )

                # Insert edge into the knowledge graph
                await self.chunk_entity_relation_graph.upsert_edge(
                    src_id,
                    tgt_id,
                    edge_data={
                        "weight": weight,
                        "description": description,
                        "keywords": keywords,
                        "source_id": source_id,
                        "file_path": file_path,
                        "created_at": int(time.time()),
                    },
                )

                edge_data: dict[str, str] = {
                    "src_id": src_id,
                    "tgt_id": tgt_id,
                    "description": description,
                    "keywords": keywords,
                    "source_id": source_id,
                    "weight": weight,
                    "file_path": file_path,
                    "created_at": int(time.time()),
                }
                all_relationships_data.append(edge_data)
                update_storage = True

            # Insert entities into vector storage with consistent format
            data_for_vdb = {
                compute_mdhash_id(dp["entity_name"], prefix="ent-"): {
                    "content": dp["entity_name"] + "\n" + dp["description"],
                    "entity_name": dp["entity_name"],
                    "source_id": dp["source_id"],
                    "description": dp["description"],
                    "entity_type": dp["entity_type"],
                    "file_path": dp.get("file_path", "custom_kg"),
                }
                for dp in all_entities_data
            }
            await self.entities_vdb.upsert(data_for_vdb)

            # Insert relationships into vector storage with consistent format
            data_for_vdb = {
                compute_mdhash_id(dp["src_id"] + dp["tgt_id"], prefix="rel-"): {
                    "src_id": dp["src_id"],
                    "tgt_id": dp["tgt_id"],
                    "source_id": dp["source_id"],
                    "content": f"{dp['keywords']}\t{dp['src_id']}\n{dp['tgt_id']}\n{dp['description']}",
                    "keywords": dp["keywords"],
                    "description": dp["description"],
                    "weight": dp["weight"],
                    "file_path": dp.get("file_path", "custom_kg"),
                }
                for dp in all_relationships_data
            }
            await self.relationships_vdb.upsert(data_for_vdb)

        except Exception as e:
            logger.error(f"Error in ainsert_custom_kg: {e}")
            raise
        finally:
            if update_storage:
                await self._insert_done()

    def query(
        self,
        query: str,
        param: QueryParam = QueryParam(),
        system_prompt: str | None = None,
    ) -> str | Iterator[str]:
        """
        Perform a sync query.

        Args:
            query (str): The query to be executed.
            param (QueryParam): Configuration parameters for query execution.
            prompt (Optional[str]): Custom prompts for fine-tuned control over the system's behavior. Defaults to None, which uses PROMPTS["rag_response"].

        Returns:
            str: The result of the query execution.
        """
        loop = always_get_an_event_loop()

        return loop.run_until_complete(self.aquery(query, param, system_prompt))  # type: ignore

    async def aquery(
        self,
        query: str,
        param: QueryParam = QueryParam(),
        system_prompt: str | None = None,
    ) -> str | AsyncIterator[str]:
        """
        Perform a async query.

        Args:
            query (str): The query to be executed.
            param (QueryParam): Configuration parameters for query execution.
                If param.model_func is provided, it will be used instead of the global model.
            prompt (Optional[str]): Custom prompts for fine-tuned control over the system's behavior. Defaults to None, which uses PROMPTS["rag_response"].

        Returns:
            str: The result of the query execution.
        """
        # If a custom model is provided in param, temporarily update global config
        global_config = asdict(self)
        # Save original query for vector search
        param.original_query = query

        if param.mode in ["local", "global", "hybrid", "mix"]:
            response = await kg_query(
                query.strip(),
                self.chunk_entity_relation_graph,
                self.entities_vdb,
                self.relationships_vdb,
                self.text_chunks,
                param,
                global_config,
                hashing_kv=self.llm_response_cache,
                system_prompt=system_prompt,
                chunks_vdb=self.chunks_vdb,
            )
        elif param.mode == "naive":
            response = await naive_query(
                query.strip(),
                self.chunks_vdb,
                param,
                global_config,
                hashing_kv=self.llm_response_cache,
                system_prompt=system_prompt,
            )
        elif param.mode == "bypass":
            # Bypass mode: directly use LLM without knowledge retrieval
            use_llm_func = param.model_func or global_config["llm_model_func"]
            # Apply higher priority (8) to entity/relation summary tasks
            use_llm_func = partial(use_llm_func, _priority=8)

            param.stream = True if param.stream is None else param.stream
            response = await use_llm_func(
                query.strip(),
                system_prompt=system_prompt,
                history_messages=param.conversation_history,
                stream=param.stream,
            )
        else:
            raise ValueError(f"Unknown mode {param.mode}")
        await self._query_done()
        return response

    # TODO: Deprecated, use user_prompt in QueryParam instead
    def query_with_separate_keyword_extraction(
        self, query: str, prompt: str, param: QueryParam = QueryParam()
    ):
        """
        Query with separate keyword extraction step.

        This method extracts keywords from the query first, then uses them for the query.

        Args:
            query: User query
            prompt: Additional prompt for the query
            param: Query parameters

        Returns:
            Query response
        """
        loop = always_get_an_event_loop()
        return loop.run_until_complete(
            self.aquery_with_separate_keyword_extraction(query, prompt, param)
        )

    # TODO: Deprecated, use user_prompt in QueryParam instead
    async def aquery_with_separate_keyword_extraction(
        self, query: str, prompt: str, param: QueryParam = QueryParam()
    ) -> str | AsyncIterator[str]:
        """
        Async version of query_with_separate_keyword_extraction.

        Args:
            query: User query
            prompt: Additional prompt for the query
            param: Query parameters

        Returns:
            Query response or async iterator
        """
        response = await query_with_keywords(
            query=query,
            prompt=prompt,
            param=param,
            knowledge_graph_inst=self.chunk_entity_relation_graph,
            entities_vdb=self.entities_vdb,
            relationships_vdb=self.relationships_vdb,
            chunks_vdb=self.chunks_vdb,
            text_chunks_db=self.text_chunks,
            global_config=asdict(self),
            hashing_kv=self.llm_response_cache,
        )

        await self._query_done()
        return response

    async def _query_done(self):
        await self.llm_response_cache.index_done_callback()

    async def aclear_cache(self, modes: list[str] | None = None) -> None:
        """Clear cache data from the LLM response cache storage.

        Args:
            modes (list[str] | None): Modes of cache to clear. Options: ["default", "naive", "local", "global", "hybrid", "mix"].
                             "default" represents extraction cache.
                             If None, clears all cache.

        Example:
            # Clear all cache
            await rag.aclear_cache()

            # Clear local mode cache
            await rag.aclear_cache(modes=["local"])

            # Clear extraction cache
            await rag.aclear_cache(modes=["default"])
        """
        if not self.llm_response_cache:
            logger.warning("No cache storage configured")
            return

        valid_modes = ["default", "naive", "local", "global", "hybrid", "mix"]

        # Validate input
        if modes and not all(mode in valid_modes for mode in modes):
            raise ValueError(f"Invalid mode. Valid modes are: {valid_modes}")

        try:
            # Reset the cache storage for specified mode
            if modes:
                success = await self.llm_response_cache.drop_cache_by_modes(modes)
                if success:
                    logger.info(f"Cleared cache for modes: {modes}")
                else:
                    logger.warning(f"Failed to clear cache for modes: {modes}")
            else:
                # Clear all modes
                success = await self.llm_response_cache.drop_cache_by_modes(valid_modes)
                if success:
                    logger.info("Cleared all cache")
                else:
                    logger.warning("Failed to clear all cache")

            await self.llm_response_cache.index_done_callback()

        except Exception as e:
            logger.error(f"Error while clearing cache: {e}")

    def clear_cache(self, modes: list[str] | None = None) -> None:
        """Synchronous version of aclear_cache."""
        return always_get_an_event_loop().run_until_complete(self.aclear_cache(modes))

    async def get_docs_by_status(
        self, status: DocStatus
    ) -> dict[str, DocProcessingStatus]:
        """Get documents by status

        Returns:
            Dict with document id is keys and document status is values
        """
        return await self.doc_status.get_docs_by_status(status)

    async def aget_docs_by_ids(
        self, ids: str | list[str]
    ) -> dict[str, DocProcessingStatus]:
        """Retrieves the processing status for one or more documents by their IDs.

        Args:
            ids: A single document ID (string) or a list of document IDs (list of strings).

        Returns:
            A dictionary where keys are the document IDs for which a status was found,
            and values are the corresponding DocProcessingStatus objects. IDs that
            are not found in the storage will be omitted from the result dictionary.
        """
        if isinstance(ids, str):
            # Ensure input is always a list of IDs for uniform processing
            id_list = [ids]
        elif (
            ids is None
        ):  # Handle potential None input gracefully, although type hint suggests str/list
            logger.warning(
                "aget_docs_by_ids called with None input, returning empty dict."
            )
            return {}
        else:
            # Assume input is already a list if not a string
            id_list = ids

        # Return early if the final list of IDs is empty
        if not id_list:
            logger.debug("aget_docs_by_ids called with an empty list of IDs.")
            return {}

        # Create tasks to fetch document statuses concurrently using the doc_status storage
        tasks = [self.doc_status.get_by_id(doc_id) for doc_id in id_list]
        # Execute tasks concurrently and gather the results. Results maintain order.
        # Type hint indicates results can be DocProcessingStatus or None if not found.
        results_list: list[Optional[DocProcessingStatus]] = await asyncio.gather(*tasks)

        # Build the result dictionary, mapping found IDs to their statuses
        found_statuses: dict[str, DocProcessingStatus] = {}
        # Keep track of IDs for which no status was found (for logging purposes)
        not_found_ids: list[str] = []

        # Iterate through the results, correlating them back to the original IDs
        for i, status_obj in enumerate(results_list):
            doc_id = id_list[
                i
            ]  # Get the original ID corresponding to this result index
            if status_obj:
                # If a status object was returned (not None), add it to the result dict
                found_statuses[doc_id] = status_obj
            else:
                # If status_obj is None, the document ID was not found in storage
                not_found_ids.append(doc_id)

        # Log a warning if any of the requested document IDs were not found
        if not_found_ids:
            logger.warning(
                f"Document statuses not found for the following IDs: {not_found_ids}"
            )

        # Return the dictionary containing statuses only for the found document IDs
        return found_statuses

    async def adelete_by_doc_id(self, doc_id: str) -> DeletionResult:
        """Delete a document and all its related data, including chunks, graph elements, and cached entries.

        This method orchestrates a comprehensive deletion process for a given document ID.
        It ensures that not only the document itself but also all its derived and associated
        data across different storage layers are removed. If entities or relationships are partially affected, it triggers.

        Args:
            doc_id (str): The unique identifier of the document to be deleted.

        Returns:
            DeletionResult: An object containing the outcome of the deletion process.
                - `status` (str): "success", "not_found", or "failure".
                - `doc_id` (str): The ID of the document attempted to be deleted.
                - `message` (str): A summary of the operation's result.
                - `status_code` (int): HTTP status code (e.g., 200, 404, 500).
                - `file_path` (str | None): The file path of the deleted document, if available.
        """
        deletion_operations_started = False
        original_exception = None

        # Get pipeline status shared data and lock for status updates
        pipeline_status = await get_namespace_data("pipeline_status")
        pipeline_status_lock = get_pipeline_status_lock()

        async with pipeline_status_lock:
            log_message = f"Starting deletion process for document {doc_id}"
            logger.info(log_message)
            pipeline_status["latest_message"] = log_message
            pipeline_status["history_messages"].append(log_message)

        try:
            # 1. Get the document status and related data
            doc_status_data = await self.doc_status.get_by_id(doc_id)
            file_path = doc_status_data.get("file_path") if doc_status_data else None
            if not doc_status_data:
                logger.warning(f"Document {doc_id} not found")
                return DeletionResult(
                    status="not_found",
                    doc_id=doc_id,
                    message=f"Document {doc_id} not found.",
                    status_code=404,
                    file_path="",
                )

            # 2. Get chunk IDs from document status
            chunk_ids = set(doc_status_data.get("chunks_list", []))

            if not chunk_ids:
                logger.warning(f"No chunks found for document {doc_id}")
                # Mark that deletion operations have started
                deletion_operations_started = True
                try:
                    # Still need to delete the doc status and full doc
                    await self.full_docs.delete([doc_id])
                    await self.doc_status.delete([doc_id])
                    logger.info(f"Deleted document {doc_id} with no associated chunks")
                except Exception as e:
                    logger.error(
                        f"Failed to delete document {doc_id} with no chunks: {e}"
                    )
                    raise Exception(f"Failed to delete document entry: {e}") from e

                async with pipeline_status_lock:
                    log_message = (
                        f"Document {doc_id} is deleted without associated chunks."
                    )
                    logger.info(log_message)
                    pipeline_status["latest_message"] = log_message
                    pipeline_status["history_messages"].append(log_message)

                return DeletionResult(
                    status="success",
                    doc_id=doc_id,
                    message=log_message,
                    status_code=200,
                    file_path=file_path,
                )

            # Mark that deletion operations have started
            deletion_operations_started = True

            # 4. Analyze entities and relationships that will be affected
            entities_to_delete = set()
            entities_to_rebuild = {}  # entity_name -> remaining_chunk_ids
            relationships_to_delete = set()
            relationships_to_rebuild = {}  # (src, tgt) -> remaining_chunk_ids

            # Use graph database lock to ensure atomic merges and updates
            graph_db_lock = get_graph_db_lock(enable_logging=False)
            async with graph_db_lock:
                try:
                    # Get all affected nodes and edges in batch
                    # logger.info(
                    #     f"Analyzing affected entities and relationships for {len(chunk_ids)} chunks"
                    # )
                    affected_nodes = (
                        await self.chunk_entity_relation_graph.get_nodes_by_chunk_ids(
                            list(chunk_ids)
                        )
                    )

                    affected_edges = (
                        await self.chunk_entity_relation_graph.get_edges_by_chunk_ids(
                            list(chunk_ids)
                        )
                    )

                except Exception as e:
                    logger.error(f"Failed to analyze affected graph elements: {e}")
                    raise Exception(f"Failed to analyze graph dependencies: {e}") from e

                try:
                    # Process entities
                    for node_data in affected_nodes:
                        node_label = node_data.get("entity_id")
                        if node_label and "source_id" in node_data:
                            sources = set(node_data["source_id"].split(GRAPH_FIELD_SEP))
                            remaining_sources = sources - chunk_ids

                            if not remaining_sources:
                                entities_to_delete.add(node_label)
                            elif remaining_sources != sources:
                                entities_to_rebuild[node_label] = remaining_sources

                    async with pipeline_status_lock:
                        log_message = (
                            f"Found {len(entities_to_rebuild)} affected entities"
                        )
                        logger.info(log_message)
                        pipeline_status["latest_message"] = log_message
                        pipeline_status["history_messages"].append(log_message)

                    # Process relationships
                    for edge_data in affected_edges:
                        src = edge_data.get("source")
                        tgt = edge_data.get("target")

                        if src and tgt and "source_id" in edge_data:
                            edge_tuple = tuple(sorted((src, tgt)))
                            if (
                                edge_tuple in relationships_to_delete
                                or edge_tuple in relationships_to_rebuild
                            ):
                                continue

                            sources = set(edge_data["source_id"].split(GRAPH_FIELD_SEP))
                            remaining_sources = sources - chunk_ids

                            if not remaining_sources:
                                relationships_to_delete.add(edge_tuple)
                            elif remaining_sources != sources:
                                relationships_to_rebuild[edge_tuple] = remaining_sources

                    async with pipeline_status_lock:
                        log_message = (
                            f"Found {len(relationships_to_rebuild)} affected relations"
                        )
                        logger.info(log_message)
                        pipeline_status["latest_message"] = log_message
                        pipeline_status["history_messages"].append(log_message)

                except Exception as e:
                    logger.error(f"Failed to process graph analysis results: {e}")
                    raise Exception(f"Failed to process graph dependencies: {e}") from e

                # 5. Delete chunks from storage
                if chunk_ids:
                    try:
                        await self.chunks_vdb.delete(chunk_ids)
                        await self.text_chunks.delete(chunk_ids)

                        async with pipeline_status_lock:
                            log_message = f"Successfully deleted {len(chunk_ids)} chunks from storage"
                            logger.info(log_message)
                            pipeline_status["latest_message"] = log_message
                            pipeline_status["history_messages"].append(log_message)

                    except Exception as e:
                        logger.error(f"Failed to delete chunks: {e}")
                        raise Exception(f"Failed to delete document chunks: {e}") from e

                # 6. Delete entities that have no remaining sources
                if entities_to_delete:
                    try:
                        # Delete from vector database
                        entity_vdb_ids = [
                            compute_mdhash_id(entity, prefix="ent-")
                            for entity in entities_to_delete
                        ]
                        await self.entities_vdb.delete(entity_vdb_ids)

                        # Delete from graph
                        await self.chunk_entity_relation_graph.remove_nodes(
                            list(entities_to_delete)
                        )

                        async with pipeline_status_lock:
                            log_message = f"Successfully deleted {len(entities_to_delete)} entities"
                            logger.info(log_message)
                            pipeline_status["latest_message"] = log_message
                            pipeline_status["history_messages"].append(log_message)

                    except Exception as e:
                        logger.error(f"Failed to delete entities: {e}")
                        raise Exception(f"Failed to delete entities: {e}") from e

                # 7. Delete relationships that have no remaining sources
                if relationships_to_delete:
                    try:
                        # Delete from vector database
                        rel_ids_to_delete = []
                        for src, tgt in relationships_to_delete:
                            rel_ids_to_delete.extend(
                                [
                                    compute_mdhash_id(src + tgt, prefix="rel-"),
                                    compute_mdhash_id(tgt + src, prefix="rel-"),
                                ]
                            )
                        await self.relationships_vdb.delete(rel_ids_to_delete)

                        # Delete from graph
                        await self.chunk_entity_relation_graph.remove_edges(
                            list(relationships_to_delete)
                        )

                        async with pipeline_status_lock:
                            log_message = f"Successfully deleted {len(relationships_to_delete)} relations"
                            logger.info(log_message)
                            pipeline_status["latest_message"] = log_message
                            pipeline_status["history_messages"].append(log_message)

                    except Exception as e:
                        logger.error(f"Failed to delete relationships: {e}")
                        raise Exception(f"Failed to delete relationships: {e}") from e

                # 8. Rebuild entities and relationships from remaining chunks
                if entities_to_rebuild or relationships_to_rebuild:
                    try:
                        await _rebuild_knowledge_from_chunks(
                            entities_to_rebuild=entities_to_rebuild,
                            relationships_to_rebuild=relationships_to_rebuild,
                            knowledge_graph_inst=self.chunk_entity_relation_graph,
                            entities_vdb=self.entities_vdb,
                            relationships_vdb=self.relationships_vdb,
                            text_chunks_storage=self.text_chunks,
                            llm_response_cache=self.llm_response_cache,
                            global_config=asdict(self),
                            pipeline_status=pipeline_status,
                            pipeline_status_lock=pipeline_status_lock,
                        )

                    except Exception as e:
                        logger.error(f"Failed to rebuild knowledge from chunks: {e}")
                        raise Exception(
                            f"Failed to rebuild knowledge graph: {e}"
                        ) from e

            # 9. Delete original document and status
            try:
                await self.full_docs.delete([doc_id])
                await self.doc_status.delete([doc_id])
            except Exception as e:
                logger.error(f"Failed to delete document and status: {e}")
                raise Exception(f"Failed to delete document and status: {e}") from e

            return DeletionResult(
                status="success",
                doc_id=doc_id,
                message=log_message,
                status_code=200,
                file_path=file_path,
            )

        except Exception as e:
            original_exception = e
            error_message = f"Error while deleting document {doc_id}: {e}"
            logger.error(error_message)
            logger.error(traceback.format_exc())
            return DeletionResult(
                status="fail",
                doc_id=doc_id,
                message=error_message,
                status_code=500,
                file_path=file_path,
            )

        finally:
            # ALWAYS ensure persistence if any deletion operations were started
            if deletion_operations_started:
                try:
                    await self._insert_done()
                except Exception as persistence_error:
                    persistence_error_msg = f"Failed to persist data after deletion attempt for {doc_id}: {persistence_error}"
                    logger.error(persistence_error_msg)
                    logger.error(traceback.format_exc())

                    # If there was no original exception, this persistence error becomes the main error
                    if original_exception is None:
                        return DeletionResult(
                            status="fail",
                            doc_id=doc_id,
                            message=f"Deletion completed but failed to persist changes: {persistence_error}",
                            status_code=500,
                            file_path=file_path,
                        )
                    # If there was an original exception, log the persistence error but don't override the original error
                    # The original error result was already returned in the except block
            else:
                logger.debug(
                    f"No deletion operations were started for document {doc_id}, skipping persistence"
                )

    async def adelete_by_entity(self, entity_name: str) -> DeletionResult:
        """Asynchronously delete an entity and all its relationships.

        Args:
            entity_name: Name of the entity to delete.

        Returns:
            DeletionResult: An object containing the outcome of the deletion process.
        """
        from .utils_graph import adelete_by_entity

        return await adelete_by_entity(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            entity_name,
        )

    def delete_by_entity(self, entity_name: str) -> DeletionResult:
        """Synchronously delete an entity and all its relationships.

        Args:
            entity_name: Name of the entity to delete.

        Returns:
            DeletionResult: An object containing the outcome of the deletion process.
        """
        loop = always_get_an_event_loop()
        return loop.run_until_complete(self.adelete_by_entity(entity_name))

    async def adelete_by_relation(
        self, source_entity: str, target_entity: str
    ) -> DeletionResult:
        """Asynchronously delete a relation between two entities.

        Args:
            source_entity: Name of the source entity.
            target_entity: Name of the target entity.

        Returns:
            DeletionResult: An object containing the outcome of the deletion process.
        """
        from .utils_graph import adelete_by_relation

        return await adelete_by_relation(
            self.chunk_entity_relation_graph,
            self.relationships_vdb,
            source_entity,
            target_entity,
        )

    def delete_by_relation(
        self, source_entity: str, target_entity: str
    ) -> DeletionResult:
        """Synchronously delete a relation between two entities.

        Args:
            source_entity: Name of the source entity.
            target_entity: Name of the target entity.

        Returns:
            DeletionResult: An object containing the outcome of the deletion process.
        """
        loop = always_get_an_event_loop()
        return loop.run_until_complete(
            self.adelete_by_relation(source_entity, target_entity)
        )

    async def get_processing_status(self) -> dict[str, int]:
        """Get current document processing status counts

        Returns:
            Dict with counts for each status
        """
        return await self.doc_status.get_status_counts()

    async def get_entity_info(
        self, entity_name: str, include_vector_data: bool = False
    ) -> dict[str, str | None | dict[str, str]]:
        """Get detailed information of an entity"""
        from .utils_graph import get_entity_info

        return await get_entity_info(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            entity_name,
            include_vector_data,
        )

    async def get_relation_info(
        self, src_entity: str, tgt_entity: str, include_vector_data: bool = False
    ) -> dict[str, str | None | dict[str, str]]:
        """Get detailed information of a relationship"""
        from .utils_graph import get_relation_info

        return await get_relation_info(
            self.chunk_entity_relation_graph,
            self.relationships_vdb,
            src_entity,
            tgt_entity,
            include_vector_data,
        )

    async def aedit_entity(
        self, entity_name: str, updated_data: dict[str, str], allow_rename: bool = True
    ) -> dict[str, Any]:
        """Asynchronously edit entity information.

        Updates entity information in the knowledge graph and re-embeds the entity in the vector database.

        Args:
            entity_name: Name of the entity to edit
            updated_data: Dictionary containing updated attributes, e.g. {"description": "new description", "entity_type": "new type"}
            allow_rename: Whether to allow entity renaming, defaults to True

        Returns:
            Dictionary containing updated entity information
        """
        from .utils_graph import aedit_entity

        return await aedit_entity(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            entity_name,
            updated_data,
            allow_rename,
        )

    def edit_entity(
        self, entity_name: str, updated_data: dict[str, str], allow_rename: bool = True
    ) -> dict[str, Any]:
        loop = always_get_an_event_loop()
        return loop.run_until_complete(
            self.aedit_entity(entity_name, updated_data, allow_rename)
        )

    async def aedit_relation(
        self, source_entity: str, target_entity: str, updated_data: dict[str, Any]
    ) -> dict[str, Any]:
        """Asynchronously edit relation information.

        Updates relation (edge) information in the knowledge graph and re-embeds the relation in the vector database.

        Args:
            source_entity: Name of the source entity
            target_entity: Name of the target entity
            updated_data: Dictionary containing updated attributes, e.g. {"description": "new description", "keywords": "new keywords"}

        Returns:
            Dictionary containing updated relation information
        """
        from .utils_graph import aedit_relation

        return await aedit_relation(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            source_entity,
            target_entity,
            updated_data,
        )

    def edit_relation(
        self, source_entity: str, target_entity: str, updated_data: dict[str, Any]
    ) -> dict[str, Any]:
        loop = always_get_an_event_loop()
        return loop.run_until_complete(
            self.aedit_relation(source_entity, target_entity, updated_data)
        )

    async def acreate_entity(
        self, entity_name: str, entity_data: dict[str, Any]
    ) -> dict[str, Any]:
        """Asynchronously create a new entity.

        Creates a new entity in the knowledge graph and adds it to the vector database.

        Args:
            entity_name: Name of the new entity
            entity_data: Dictionary containing entity attributes, e.g. {"description": "description", "entity_type": "type"}

        Returns:
            Dictionary containing created entity information
        """
        from .utils_graph import acreate_entity

        return await acreate_entity(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            entity_name,
            entity_data,
        )

    def create_entity(
        self, entity_name: str, entity_data: dict[str, Any]
    ) -> dict[str, Any]:
        loop = always_get_an_event_loop()
        return loop.run_until_complete(self.acreate_entity(entity_name, entity_data))

    async def acreate_relation(
        self, source_entity: str, target_entity: str, relation_data: dict[str, Any]
    ) -> dict[str, Any]:
        """Asynchronously create a new relation between entities.

        Creates a new relation (edge) in the knowledge graph and adds it to the vector database.

        Args:
            source_entity: Name of the source entity
            target_entity: Name of the target entity
            relation_data: Dictionary containing relation attributes, e.g. {"description": "description", "keywords": "keywords"}

        Returns:
            Dictionary containing created relation information
        """
        from .utils_graph import acreate_relation

        return await acreate_relation(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            source_entity,
            target_entity,
            relation_data,
        )

    def create_relation(
        self, source_entity: str, target_entity: str, relation_data: dict[str, Any]
    ) -> dict[str, Any]:
        loop = always_get_an_event_loop()
        return loop.run_until_complete(
            self.acreate_relation(source_entity, target_entity, relation_data)
        )

    async def amerge_entities(
        self,
        source_entities: list[str],
        target_entity: str,
        merge_strategy: dict[str, str] = None,
        target_entity_data: dict[str, Any] = None,
    ) -> dict[str, Any]:
        """Asynchronously merge multiple entities into one entity.

        Merges multiple source entities into a target entity, handling all relationships,
        and updating both the knowledge graph and vector database.

        Args:
            source_entities: List of source entity names to merge
            target_entity: Name of the target entity after merging
            merge_strategy: Merge strategy configuration, e.g. {"description": "concatenate", "entity_type": "keep_first"}
                Supported strategies:
                - "concatenate": Concatenate all values (for text fields)
                - "keep_first": Keep the first non-empty value
                - "keep_last": Keep the last non-empty value
                - "join_unique": Join all unique values (for fields separated by delimiter)
            target_entity_data: Dictionary of specific values to set for the target entity,
                overriding any merged values, e.g. {"description": "custom description", "entity_type": "PERSON"}

        Returns:
            Dictionary containing the merged entity information
        """
        from .utils_graph import amerge_entities

        return await amerge_entities(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            source_entities,
            target_entity,
            merge_strategy,
            target_entity_data,
        )

    def merge_entities(
        self,
        source_entities: list[str],
        target_entity: str,
        merge_strategy: dict[str, str] = None,
        target_entity_data: dict[str, Any] = None,
    ) -> dict[str, Any]:
        loop = always_get_an_event_loop()
        return loop.run_until_complete(
            self.amerge_entities(
                source_entities, target_entity, merge_strategy, target_entity_data
            )
        )

    async def aexport_data(
        self,
        output_path: str,
        file_format: Literal["csv", "excel", "md", "txt"] = "csv",
        include_vector_data: bool = False,
    ) -> None:
        """
        Asynchronously exports all entities, relations, and relationships to various formats.
        Args:
            output_path: The path to the output file (including extension).
            file_format: Output format - "csv", "excel", "md", "txt".
                - csv: Comma-separated values file
                - excel: Microsoft Excel file with multiple sheets
                - md: Markdown tables
                - txt: Plain text formatted output
                - table: Print formatted tables to console
            include_vector_data: Whether to include data from the vector database.
        """
        from .utils import aexport_data as utils_aexport_data

        await utils_aexport_data(
            self.chunk_entity_relation_graph,
            self.entities_vdb,
            self.relationships_vdb,
            output_path,
            file_format,
            include_vector_data,
        )

    def export_data(
        self,
        output_path: str,
        file_format: Literal["csv", "excel", "md", "txt"] = "csv",
        include_vector_data: bool = False,
    ) -> None:
        """
        Synchronously exports all entities, relations, and relationships to various formats.
        Args:
            output_path: The path to the output file (including extension).
            file_format: Output format - "csv", "excel", "md", "txt".
                - csv: Comma-separated values file
                - excel: Microsoft Excel file with multiple sheets
                - md: Markdown tables
                - txt: Plain text formatted output
                - table: Print formatted tables to console
            include_vector_data: Whether to include data from the vector database.
        """
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

        loop.run_until_complete(
            self.aexport_data(output_path, file_format, include_vector_data)
        )
'''
